//// ====================================
//// BEGIN type definitions

MayContext(ctx) -> .
lang:entity(`MayContext).
lang:physical:storageModel[`MayContext]="ScalableSparse".
lang:physical:capacity[`MayContext] = 4294967296.

InitialMayContext[] = ctx -> MayContext(ctx).
lang:skolem(`InitialMayContext).
InitialMayContext[] = ctx, MayContext(ctx).

PushMayContext[invo, ctx] = pushedCtx ->
  MethodInvocation(invo), MayContext(ctx), MayContext(pushedCtx).
lang:skolem(`PushMayContext).


MayHeapContext(hctx) -> .
lang:entity(`MayHeapContext).
lang:physical:storageModel[`MayHeapContext]="ScalableSparse".
lang:physical:capacity[`MayHeapContext] = 8388608.

EmptyHeapContext[] = hctx -> MayHeapContext(hctx).
lang:skolem(`EmptyHeapContext).

EmptyHeapContext[] = hctx, MayHeapContext(hctx).

//// END type definitions
//// ====================================


InitialRootMethodForMayAnalysis(method) -> Method(method).
EmptyHeapContext(hctx) -> MayHeapContext(hctx).
InitialMayContext(ctx) -> MayContext(ctx).
MaxMayContextDepth(num) -> int(num).
AccessPath_MaxLength(maxLen) -> int(maxLen).
FirstInstructionOfMethod(method, firstInsn) -> Method(method), Instruction(firstInsn).

component IntraproceduralMust {
#include "IntraproceduralMust.logic"
}

//component SoundMay {
//#include "SoundMay.logic"
//}


LibraryCollectionRoot(type) -> Type(type).
LibraryCollectionType(type) -> Type(type).

LibraryCollectionRoot(type) <-
  type = "java.util.AbstractCollection";
  type = "java.util.AbstractMap".
LibraryCollectionType(type) <-
  SubtypeOf(type, collRoot),
  LibraryCollectionRoot(collRoot).

//// TODO: model iterators
LibraryCollectionStoreOperation(invo) -> MethodInvocation(invo).
LibraryCollectionLoadOperation(invo) -> MethodInvocation(invo).

LibraryCollectionStoreOperation(invo) <-
  VirtualMethodInvocation_SimpleName(invo, "add");
  VirtualMethodInvocation_SimpleName(invo, "push");
  VirtualMethodInvocation_SimpleName(invo, "set");
  VirtualMethodInvocation_SimpleName(invo, "put").
LibraryCollectionLoadOperation(invo) <-
  VirtualMethodInvocation_SimpleName(invo, "peek"),
  VirtualMethodInvocation_SimpleName(invo, "pop"),
  VirtualMethodInvocation_SimpleName(invo, "elementAt"),
  VirtualMethodInvocation_SimpleName(invo, "firstElement"),
  VirtualMethodInvocation_SimpleName(invo, "lastElement"),
  VirtualMethodInvocation_SimpleName(invo, "remove"),
  VirtualMethodInvocation_SimpleName(invo, "get"). // TODO: better match in future

StoreCollection_From(insn, from) -> Instruction(insn), Var(from).
StoreCollection_From(insn, from) <-
  StoreArrayIndex_From(insn, from).
StoreCollection_From(invo, from) <-
  LibraryCollectionStoreOperation(invo),
  (ActualParam(1, invo, from);
   ActualParam(2, invo, from)).

StoreCollection_Base(insn, from) -> Instruction(insn), Var(from).
StoreCollection_Base(insn, var) <-
  StoreArrayIndex_Base(insn, var).
StoreCollection_Base(invo, var) <-
  LibraryCollectionStoreOperation(invo),
  VirtualMethodInvocation_Base(invo, var).

// now loads
LoadCollection_Base(insn, to) -> Instruction(insn), Var(to).
LoadCollection_To(insn, to) -> Instruction(insn), Var(to).

LoadCollection_To(insn, to) <-
  LoadArrayIndex_To(insn, to).
LoadCollection_To(invo, to) <-
  LibraryCollectionLoadOperation(invo),
  AssignReturnValue(invo, to).

LoadCollection_Base(insn, var) <-
  LoadArrayIndex_Base(insn, var).
LoadCollection_Base(invo, var) <-
  LibraryCollectionLoadOperation(invo),
  VirtualMethodInvocation_Base(invo, var).


//// POINT2---IgnorableMethodInvocation to go here

//// ====================================
//// BEGIN configuration
//// Different ways to kick-start the analysis.

MaxMayContextDepth(4).

AccessPath_MaxLength(3).





//// ====================================
//// BEGIN utilities

// Try to discover hidden "main" heuristically
AppMainMethod(mainMethod) -> Method(mainMethod).
AppMainMethod(mainMethod) <-
  MethodSignature_SimpleName(mainMethod, "main"),
  MethodSignature_DeclaringType(mainMethod, class),
  ApplicationClass(class).

// Heuristic: if you can reach it in the analysis and it's a static
// initializer, start a new search (with zero context depth) from it.
// There are lots of static final fields in the library that see heavy
// use.
ClinitMethodOfClass(method, class) -> Method(method), Type(class).
ClinitMethodOfClass(method, class) <-
  MethodSignature_SimpleName(method, "<clinit>"),
  MethodSignature_DeclaringType(method, class).

// TODO what about the way it is computed in the must analysis (java)
FirstInstructionOfMethod(method, firstInsn) <-
  Instruction_Index(firstInsn, 1),
  !IsJumpTarget(firstInsn),
  Instruction_Method(firstInsn, method).

IgnorableMethodInvocation(invo) -> MethodInvocation(invo).
IgnorableForNonCollectionsMethodInvocation(invo) -> MethodInvocation(invo).
IgnorableForStaticsMethodInvocation(invo) -> MethodInvocation(invo).

StoreInstruction(insn) -> Instruction(insn).
StoreInstruction(insn) <-
  StoreStaticField_From(insn, _);
  StoreInstanceField_From(insn, _).

ThisVarOfConstructor(method, this) -> Method(method), Var(this).
ThisVarOfConstructor(method, this) <-
   MethodSignature_SimpleName(method, "<init>"),
   ThisVar(method, this).

BBHeadIsFirstInstruction(firstInsn) -> Instruction(firstInsn).
BBHeadIsFirstInstruction(firstInsn) <-
  BasicBlockBegin(firstInsn),
  FirstInstructionOfMethod(_, firstInsn).

// TODO why only collections (where is that enforced in the rule)
// Just a dumb overapproximation: is there any call site at all,
// resolved or otherwise used only for collections.
BasicBlockContainsCall(headInsn) -> Instruction(headInsn).
SomePathBetweenBasicBlocksContainsCall(prev, next) -> Instruction(prev), Instruction(next).
SomePathFromFirstInstructionContainsCall(blockHead) -> Instruction(blockHead).

BasicBlockContainsCall(headInsn) <-
  BasicBlockHead(insn, headInsn),
  MethodInvocation(insn),
  !IgnorableMethodInvocation(insn).

SomePathBetweenBasicBlocksContainsCall(prev, next) <-
  BasicBlockContainsCall(prev),
  MaySuccessorBBModuloThrow(next, prev).

SomePathFromFirstInstructionContainsCall(blockHead) <-
  BBHeadIsFirstInstruction(firstInsn),
  SomePathBetweenBasicBlocksContainsCall(firstInsn, blockHead).

// Initial computed access paths. Faster than doing the same thing all over
InitialComputedAccessPath(ap) -> AccessPath(ap).

// The rules below create access paths from all variables
// and all access fields in the program.
//InitialComputedAccessPath([var, nil]) <-
//  Var_Type(var, type),
//  ReferenceType(type).

//// END utilities


// Friendly API for access path display
AccessPath_ToString(ap, str) ->
   AccessPath(ap), string(str).

// loses lots of information, which may be confusing during debugging.
AccessPath_ToString(ap, str) <-
   AccessPath_ByVarInv(ap, v),
   _NameFromRefMode(v, str).
//   Var_Value(v,vs),
//   OptVar_DeclaringMethod(m,v),
//   MethodSignature_Value(m_ms),
//   str = vs + ms.

AccessPath_ToString(ap, str) <-
   AccessPath_ByStaticFieldInv(ap, f),
   _NameFromRefMode(f, str).

AccessPath_ToString(ap, str2) <-
   AccessPath_ByCollectionVarInv(ap, v),
   _NameFromRefMode(v, str),
   str2 = "collection on " + str.

AccessPath_ToString(ap, str) <-
   AccessPath_Base(ap, base),
   AccessPath_LastField(ap, fld),
   AccessPath_ToString(base, strBase),
   _NameFromRefMode(fld, fldName),
   baseDot = strBase + ".",
   str = baseDot + fldName.

_NameFromRefMode(ref, name) ->
   string(ref), string(name).

_NameFromRefMode(ref, varName) <-
   Var_Value(_:ref),
   _VarRefModeLastTokenIndex(ref, maxIdx),
   string_split[ref, "/", maxIdx] = varName.
lang:derivationType[`_NameFromRefMode] = "Derived".

_NameFromRefMode(ref, varName) <-
   FieldSignature_Value(_:ref),
   _FieldRefModeLastTokenIndex(ref, maxIdx),
   string_split[ref, "/", maxIdx] = varName.
lang:derivationType[`_NameFromRefMode] = "Derived".

_VarRefModeLastTokenIndex(ref, maxIdx) <-
   agg<<maxIdx = max(idx)>>
   Var_Value(_:ref),
   string_split[ref, "/", idx] = _.

_FieldRefModeLastTokenIndex(ref, maxIdx) <-
   agg<<maxIdx = max(idx)>>
   FieldSignature_Value(_:ref),
   string_split[ref, "/", idx] = _.


/*
  ///// POINT1--unchanged access paths code
  
  //// Dealing with unchanged access paths (below) hasn't proven
  //// worthwhile. It's not surprising. The callee has no name for
  //// this access path. The only hope is that it will survive through
  //// virtual calls and will come back to the caller (whereas the
  //// conservative must-pre-analysis won't consider virtual calls it
  //// cannot resolve in its naive way).

  // This is quite expensive if not restricted. Currently used only for
  // non-resolved virtual calls. For resolved ones, we have a frame rule
  // to propagate the information right over the method call in many
  // cases (and we ignore the rest for now).
  // ChangedBaseAtInvocation(var, invo) <-
  //   ActualParam(_, invo, var);
  //   VirtualMethodInvocation_Base(invo, var);
  //   SpecialMethodInvocation_Base(invo, var).

  // OptPotentialAccessPathMayPointToPropagation(hctx, heap, invo, calleeCtx, toMethod, ap) <-
  //   MayCallGraphEdge_ToMethod(toMethod, callerCtx, invo),
  //   !May_MustCallGraphEdge_ToMethod(callerCtx, invo, toMethod),
  //   MayCallGraphEdge_Context(callerCtx, invo, calleeCtx),
  //   Before_AccessPathMayPointTo(hctx, heap, ap, callerCtx, invo).
  
  // Before_AccessPathMayPointTo(hctx, heap, ap, calleeCtx, firstInsn) <_
  //    OptPotentialAccessPathMayPointToPropagation(hctx, heap, invo, calleeCtx, toMethod, ap),
  //    AccessPath_BaseVar(ap, baseVar),
  //    !ChangedBaseAtInvocation(baseVar, invo),
  //    SingleFieldAccessPath(fld, ap),
  //    (MethodMayAssignField(fld, toMethod);
  //     MethodHasUnresolvedInvocation(toMethod)),
  //    FirstInstructionOfMethod(toMethod, firstInsn).

  // Before_AccessPathMayPointTo(hctx, heap, ap, calleeCtx, firstInsn) <-
  //    OptPotentialAccessPathMayPointToPropagation(hctx, heap, invo, calleeCtx, toMethod, ap),
  //    AccessPath_BaseVar(ap, baseVar),
  //    !ChangedBaseAtInvocation(baseVar, invo),
  //    _DoubleFieldAccessPath(fld1, fld2, ap),
  //    (MethodMayAssignField(fld1, toMethod);
  //     MethodMayAssignField(fld2, toMethod);
  //     MethodHasUnresolvedInvocation(toMethod)),
  //    FirstInstructionOfMethod(toMethod, firstInsn).
*/


//// Enter at POINT2---IgnorableMethodInvocation 
//// ====================================
//// BEGIN configuration of ignorable method calls

// Some calls to native or otherwise complex methods need to be
// modeled, i.e., ignored. E.g., fillInStackTrace is a native method
// called in the constructor of a (ubiquitous) java.lang.Throwable. If
// not ignored, no image of the heap propagates anywhere.
// TODO: do a better match (on full sig) than just on SimpleName.

IgnorableMethodInvocation(invo) <-
   VirtualMethodInvocation_SimpleName(invo, "fillInStackTrace"); // Throwable
   VirtualMethodInvocation_SimpleName(invo, "equals");  // Object
   VirtualMethodInvocation_SimpleName(invo, "hashCode");
   VirtualMethodInvocation_SimpleName(invo, "toString");
   VirtualMethodInvocation_SimpleName(invo, "println"); // PrintStream
   StaticMethodInvocation_SimpleName(invo, "parseInt"); // Integer
   VirtualMethodInvocation_SimpleName(invo, "endsWith"); // String
   StaticMethodInvocation_SimpleName(invo, "floatToRawIntBits"); // Float
   // these are used in the HashMap "put" method!
   StaticMethodInvocation_SimpleName(invo, "intBitsToFloat"); 
   // From this point on, it's just a test to see if these natives matter.
   StaticMethodInvocation_SimpleName(invo, "encoding"); // Console
   StaticMethodInvocation_SimpleName(invo, "echo"); 
   StaticMethodInvocation_SimpleName(invo, "istty"); 
   VirtualMethodInvocation_SimpleName(invo, "sync"); // FileDescriptor
   StaticMethodInvocation_SimpleName(invo, "initIDs"); 
   VirtualMethodInvocation_SimpleName(invo, "open"); // FileInputStream
   VirtualMethodInvocation_SimpleName(invo, "read0"); 
   VirtualMethodInvocation_SimpleName(invo, "readBytes"); 
   VirtualMethodInvocation_SimpleName(invo, "skip"); 
   VirtualMethodInvocation_SimpleName(invo, "available"); 
   VirtualMethodInvocation_SimpleName(invo, "close0"); 
   VirtualMethodInvocation_SimpleName(invo, "write"); // FileOutputStream
   VirtualMethodInvocation_SimpleName(invo, "writeBytes"); 
   VirtualMethodInvocation_SimpleName(invo, "availableProcessors"); // Runtime
   VirtualMethodInvocation_SimpleName(invo, "freeMemory"); 
   VirtualMethodInvocation_SimpleName(invo, "totalMemory"); 
   VirtualMethodInvocation_SimpleName(invo, "maxMemory"); 
   VirtualMethodInvocation_SimpleName(invo, "gc"); 
   StaticMethodInvocation_SimpleName(invo, "runFinalization0"); 
   StaticMethodInvocation_SimpleName(invo, "sin"); // StrictMath
   StaticMethodInvocation_SimpleName(invo, "cos"); 
   StaticMethodInvocation_SimpleName(invo, "tan"); 
   StaticMethodInvocation_SimpleName(invo, "log"); 
   StaticMethodInvocation_SimpleName(invo, "pow");
   StaticMethodInvocation_SimpleName(invo, "currentThread"); // Thread
   StaticMethodInvocation_SimpleName(invo, "yield");
   StaticMethodInvocation_SimpleName(invo, "sleep");
   VirtualMethodInvocation_SimpleName(invo, "start0");
   VirtualMethodInvocation_SimpleName(invo, "isInterrupted");
   VirtualMethodInvocation_SimpleName(invo, "isAlive");
   StaticMethodInvocation_SimpleName(invo, "holdsLock");
   StaticMethodInvocation_SimpleName(invo, "getThreads");
   StaticMethodInvocation_SimpleName(invo, "dumpThreads");
   VirtualMethodInvocation_SimpleName(invo, "setPriority");
   VirtualMethodInvocation_SimpleName(invo, "stop0");
   VirtualMethodInvocation_SimpleName(invo, "suspend0");
   VirtualMethodInvocation_SimpleName(invo, "resume0");
   VirtualMethodInvocation_SimpleName(invo, "interrupt0");
   VirtualMethodInvocation_SimpleName(invo, "isAlive");
   VirtualMethodInvocation_SimpleName(invo, "getStackTraceDepth"); // Throwable
   VirtualMethodInvocation_SimpleName(invo, "getStackTraceElement"); 
   VirtualMethodInvocation_SimpleName(invo, "forkAndExec");  // UnixProcess
   VirtualMethodInvocation_SimpleName(invo, "wait"); // Object
   VirtualMethodInvocation_SimpleName(invo, "notify");
   VirtualMethodInvocation_SimpleName(invo, "notifyAll").

IgnorableForStaticsMethodInvocation(invo) <-
   VirtualMethodInvocation_SimpleName(invo, "intern"); // String
   VirtualMethodInvocation_SimpleName(invo, "clone"); // Object
   VirtualMethodInvocation_SimpleName(invo, "append"). // StringBuilder

// *Collections*
IgnorableForNonCollectionsMethodInvocation(invo) <-
  LibraryCollectionStoreOperation(invo);
  LibraryCollectionLoadOperation(invo).

StaticMethodInvocation_SimpleName(invo, simplename) -> MethodInvocation(invo), string(simplename).
StaticMethodInvocation_SimpleName(invo, simplename) <-
   MethodInvocation_Signature(invo, signature),
   StaticMethodInvocation_Insn(invo),
   MethodSignature_SimpleName(signature, simplename).

//// END configuration of ignorable method calls


/*
//// POINT4 code
// //// Commented out for now. Does not make that much difference. 
// //// InstanceFieldMayPointTo inferences rarely get stopped because of
// //// library calls.
// //// ------------------------------
// // Logic for assuming the library does not affect application fields,
// // except via reflection.
// ApplicationField(fld) <-
//    FieldSignature_DeclaringClass(fld, class),
//    ApplicationClass(class).

// ApplicationMethod(meth) <-
//    MethodSignature_DeclaringType(meth, declaringType),
//    ApplicationClass(declaringType).

// MethodCallsReflection(meth) <-
//    Instruction_Method(invo, meth),
//    MethodInvocation_Signature(invo, sig),
//    string_substring(sig, 0, _, "<java.lang.reflect").

// _Opt2MethodInvocation_Signature(invo, inMeth, toMeth) <-
//    (StaticMethodInvocation_Insn(invo);
//     SpecialMethodInvocation_Insn(invo)), 
//    MethodInvocation_Signature(invo, toMeth),
//    Instruction_Method(invo, inMeth).

// // exact resolution for static/special
// MethodCallsReflection(inMeth) <-
//    _Opt2MethodInvocation_Signature(_, inMeth, toMeth), 
//    MethodCallsReflection(toMeth).

// // underapproximation of virtual method resolution, as if static
// _Opt2MethodInvocation_Signature(invo, inMeth, toMeth) <-
//    VirtualMethodInvocation_Insn(invo),
//    MethodInvocation_Signature(invo, toMeth),
//    Instruction_Method(invo, inMeth).

// // Naive virtual method resolution, based on name. REVIEW: too conservative
// _OptVirtualMethodInvocation_Simplename(inMeth, simpleName) <-
//    VirtualMethodInvocation_SimpleName(invo, simpleName),
//    Instruction_Method(invo, inMeth).

// MethodCallsReflection(inMeth) <-
//    MethodCallsReflection(toMeth),
//    MethodSignature_SimpleName(toMeth, toMethSimpleName),
//    _OptVirtualMethodInvocation_Simplename(inMeth, toMethSimpleName).

// InstanceFieldMayPointTo(hctx, heap, fld, hctxBase, baseHeap, ctx, insn) <-
//    AllPredecessors_InstanceFieldMayPointTo(hctx, heap, fld, hctxBase, baseHeap, ctx, insn),
//    MethodInvocation_Signature(insn, calledMethod), // underapproximate
// //   string_substring[calledMethod, 0, string_length[str]] != str, str = "<java.lang.reflect",
//    !MethodCallsReflection(calledMethod),
//    ApplicationField(fld),
//    !ApplicationMethod(calledMethod).

// StaticFieldMayPointTo(hctx, heap, fld, ctx, insn) <-
//    AllPredecessors_StaticFieldMayPointTo(hctx, heap, fld, ctx, insn),
//    MethodInvocation_Signature(insn, calledMethod),
// //   string_substring[calledMethod, 0, string_length[str]] != str, str = "<java.lang.reflect",
//    !MethodCallsReflection(calledMethod),
//    ApplicationField(fld),
//    !ApplicationMethod(calledMethod).

// // TODO: also extend to collections
*/


/*
//// POINT5: DominatedPathMayInvalidateFieldPointsTo
// // TODO: currently has no impact. Comment out and re-check when non-invalidating
// //       method calls are added

// // Interesting addition to frame rules:
// // propagate in case of non-invalidating dominated predecessors.

// // The path (dominated by dominator) that ends at insn
// // may invalidate some field.
// DominatedPathMayInvalidateFieldPointsTo(fld, insn, dominator) <-
//    Dominates(dominator, insn),
//    BasicBlockMayInvalidateFieldPointsTo(fld, insn).

// DominatedPathMayInvalidateFieldPointsTo(fld, insn, dominator) <-
//    DominatedPathMayInvalidateFieldPointsTo(fld, otherInsn, dominator),
//    MaySuccessorBBModuloThrow(insn, otherInsn),
//    Dominates(dominator, insn).

// ExistsFieldInvalidatingPathToPredecessor(fld, prevHead, dominator) <-
//    DominatesItsPredecessorInstruction(prevInsn, dominator),
//    BasicBlockHead(prevInsn, prevHead),
//    DominatedPathMayInvalidateFieldPointsTo(fld, prevHead, dominator).

// ExistsFieldInvalidatingPathToSomePredecessor(fld, dominator) <-
//    ExistsFieldInvalidatingPathToPredecessor(fld, _, dominator).

// BasicBlockMayInvalidateAllFieldsPointsTo(headInsn) <-
//    BasicBlockHead(insn, headInsn),
//    !IndifferentInstruction(insn),
//    !FieldInstruction(insn).

// // The path (dominated by dominator) that ends at insn
// // may invalidate any field.
// DominatedPathMayInvalidateAllFieldsPointsTo(insn, dominator) <-
//    Dominates(dominator, insn),
//    BasicBlockMayInvalidateAllFieldsPointsTo(insn).

// DominatedPathMayInvalidateAllFieldsPointsTo(insn, dominator) <-
//    DominatedPathMayInvalidateAllFieldsPointsTo(otherInsn, dominator),
//    MaySuccessorBBModuloThrow(insn, otherInsn),
//    Dominates(dominator, insn).

// ExistsAllFieldsInvalidatingPathToPredecessor(prevHead, dominator) <-
//    DominatesItsPredecessorInstruction(prevInsn, dominator),
//    BasicBlockHead(prevInsn, prevHead),
//    DominatedPathMayInvalidateAllFieldsPointsTo(prevHead, dominator).

// ExistsAllFieldsInvalidatingPathToSomePredecessor(dominator) <-
//    ExistsAllFieldsInvalidatingPathToPredecessor(_, dominator).

// InstanceFieldMayPointTo(hctx, heap, fld, hctxBase, baseHeap, ctx, insn) <-
//    AllNonDomPredecessors_InstanceFieldMayPointTo(hctx, heap, fld, hctxBase, baseHeap, ctx, insn),
//    !ExistsFieldInvalidatingPathToSomePredecessor(fld, insn),
//    !ExistsAllFieldsInvalidatingPathToSomePredecessor(insn),
//    DominatesItsPredecessorInstruction(_, insn).

// StaticFieldMayPointTo(hctx, heap, fld, ctx, insn) <-
//    AllNonDomPredecessors_StaticFieldMayPointTo(hctx, heap, fld, ctx, insn),
//    !ExistsFieldInvalidatingPathToSomePredecessor(fld, insn),
//    !ExistsAllFieldsInvalidatingPathToSomePredecessor(insn),
//    DominatesItsPredecessorInstruction(_, insn).

// // TODO: update with collections
*/
