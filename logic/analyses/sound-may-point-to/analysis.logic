// A sound may-point-to analysis ("shall"-point-to?
// "True-may"-point-to?). Does not conclude anything if it is not
// certain it over-approximates all possible points-to targets. That
// is, an empty points-to set means "anything can be pointed to".

// Ignore verification of calculation in head
lang:compiler:warning:SPECIFIC_STARRED_EDGE_IN_SAFETY_GRAPH_CYCLE[] = false.

//// =====================================
//// The main concepts:

// May-point-to information in a specific context (which may be an
// all-contexts value).

// Whenever (if) it is reached under context ?ctx, variable ?var may point to an object
// allocated at site ?heap. Since we assume SSA and variables are ensured initialized before use,
// there is no point in keeping this information per-instruction.
MayPointTo(?hctx, ?heap, ?ctx, ?var) ->
   MayHeapContext(?hctx), HeapAllocation(?heap),
   Var(?var), MayContext(?ctx).

InstanceFieldMayPointTo(?hctx, ?heap, ?field, ?hctxBase, ?baseHeap, ?ctx, ?insn) ->
   MayHeapContext(?hctx), HeapAllocation(?heap),
   FieldSignature(?field), MayHeapContext(?hctxBase),
   HeapAllocation(?baseHeap), MayContext(?ctx), Instruction(?insn).

StaticFieldMayPointTo(?hctx, ?heap, ?field, ?ctx, ?insn) ->
   MayHeapContext(?hctx), HeapAllocation(?heap),
   FieldSignature(?field), MayContext(?ctx), Instruction(?insn).

ArrayIndexMayPointTo(?hctx, ?heap, ?hctxArray, ?arrayHeap, ?ctx, ?insn) ->
   MayHeapContext(?hctx), HeapAllocation(?heap),
   MayHeapContext(?hctxArray), HeapAllocation(?arrayHeap),
   MayContext(?ctx), Instruction(?insn).

RootMethodForMayAnalysis(?meth) -> MethodSignature(?meth).


//// =====================================
//// BEGIN MayPointTo code

// Need to identify relevant (i.e., reachable) methods for the
// analysis, instead of blindly applying it to all available code.
ReachableMethodUnderMayContext(?ctx, ?meth) ->
   MayContext(?ctx), MethodSignature(?meth).

ReachableMethodUnderMayContext(?ctx, ?meth) <-
   RootMethodForMayAnalysis(?meth),
   InitialMayContext[] = ?ctx.

ReachableMethodUnderMayContext(?ctx, ?meth) <-
   MayCallGraphEdge:Context[?callerCtx, ?invo] = ?ctx,
   MayCallGraphEdge:ToMethod(?meth, ?callerCtx, ?invo).

ReachableMayContext(?ctx) <-
   ReachableMethodUnderMayContext(?ctx, _).
   
// Root of all inferences. Assigning new heap allocations.
// REVIEW: This introduces dependency on string-constants.logic
//RecordMacroMay(?ctx, ?heap, ?hctx),
MayHeapContext(?hctx), EmptyHeapContext[] = ?hctx,
MayPointTo(?hctx, ?heap, ?ctx, ?var) <-
   AssignNormalHeapAllocation(?heap, ?var, ?inMeth),
   ReachableMethodUnderMayContext(?ctx, ?inMeth).

// strings and others
MayPointTo(?hctx, ?heap, ?ctx, ?var) <-
   AssignContextInsensitiveHeapAllocation(?heap, ?var, ?inMeth),
   ?hctx = EmptyHeapContext[],
   ReachableMethodUnderMayContext(?ctx, ?inMeth).


// null assignments
_OptInstruction:Method(?insn, ?inMeth) <-
   Instruction:Method[?insn] = ?inMeth.
   
MayHeapContext(?hctx), EmptyHeapContext[] = ?hctx,
MayPointTo(?hctx, ?heap, ?ctx, ?var) <-
   AssignNull:Insn(?insn),
   AssignInstruction:To[?insn] = ?var,
   HeapAllocation:Null[] = ?heap,
   _OptInstruction:Method(?insn, ?inMeth),
   ReachableMethodUnderMayContext(?ctx, ?inMeth).

// Move, but not Phi nodes, which are also represented as local assignments.
MayPointTo(?hctx, ?heap, ?ctx, ?to) <-
   AssignLocal:Insn(?insn),
   !(PhiNodeHead[?insn] = _),
   AssignInstruction:To[?insn] = ?to,
   AssignLocal:From[?insn] = ?from,
   MayPointTo(?hctx, ?heap, ?ctx, ?from).

// casts are like local assignments
MayPointTo(?hctx, ?heap, ?ctx, ?to) <-
   AssignCast:Insn(?insn),
   AssignInstruction:To[?insn] = ?to,
   AssignCast:From[?insn] = ?from,
   MayPointTo(?hctx, ?heap, ?ctx, ?from).

// Phi
MayPointTo(?hctx, ?heap, ?ctx, ?var) <-
   MayPointToUpToPhiInstruction(?hctx, ?heap, ?ctx, ?lastInsn),
   !(NextInSamePhiNode[?lastInsn] = _),
   AssignInstruction:To[?lastInsn] = ?var.

// static or special method invocation
_OptMethodInvocation:Signature(?toMeth, ?invo, ?inMeth) <-
   (StaticMethodInvocation:Insn(?invo);
    SpecialMethodInvocation:Insn(?invo)), 
   MethodInvocation:Signature[?invo] = ?toMeth,
   Instruction:Method[?invo] = ?inMeth.

//MergeMacroMay(?ctx, ?invo, ?hctx, ?heap, ?calleeCtx),
PushMayContext[?invo,?ctx] = ?calleeCtx, MayContext(?calleeCtx),
MayCallGraphEdge:ToMethod(?toMeth, ?ctx, ?invo),
MayCallGraphEdge:Context[?ctx, ?invo] = ?calleeCtx <-
   _OptMethodInvocation:Signature(?toMeth, ?invo, ?inMeth),
   ReachableMethodUnderMayContext(?ctx, ?inMeth),
   MayContextDepth[?ctx] < MaxMayContextDepth[].

// special method invocation "this" variable assignment
_OptSpecialMethodInvocation:Base(?invo, ?base) <-
   SpecialMethodInvocation:Base[?invo] = ?base.

_OptPotentialSpecialMethodBase(?hctx, ?heap, ?ctx, ?invo) <-
   _OptSpecialMethodInvocation:Base(?invo, ?base),
   MayPointTo(?hctx, ?heap, ?ctx, ?base).

MayPointTo(?hctx, ?heap, ?calleeCtx, ?this) <-
   _OptPotentialSpecialMethodBase(?hctx, ?heap, ?ctx, ?invo),
   MayCallGraphEdge:ToMethod(?toMeth, ?ctx, ?invo),
   MayCallGraphEdge:Context[?ctx, ?invo] = ?calleeCtx,
   ThisVar[?toMeth] = ?this.

_OptVirtualMethodInvocation:Base(?invo, ?base) <-
   VirtualMethodInvocation:Base[?invo] = ?base.

_OptPotentialVirtualMethodBase(?hctx, ?heap, ?ctx, ?invo) <-
   _OptVirtualMethodInvocation:Base(?invo, ?base),
   MayPointTo(?hctx, ?heap, ?ctx, ?base).

// virtual method invocation
//MergeMacroMay(?ctx, ?invo, ?hctx, ?heap, ?calleeCtx),
PushMayContext[?invo,?ctx] = ?calleeCtx, MayContext(?calleeCtx),
MayCallGraphEdge:ToMethod(?toMeth, ?ctx, ?invo),
MayCallGraphEdge:Context[?ctx, ?invo] = ?calleeCtx,
MayPointTo(?hctx, ?heap, ?calleeCtx, ?this) <-
   _OptPotentialVirtualMethodBase(?hctx, ?heap, ?ctx, ?invo),
   HeapAllocation:Type[?heap] = ?heaptype,
   VirtualMethodInvocation:SimpleName[?invo] = ?simplename,
   VirtualMethodInvocation:Descriptor[?invo] = ?descriptor,
   MethodLookup[?simplename, ?descriptor, ?heaptype] = ?toMeth,
   ThisVar[?toMeth] = ?this,
   MayContextDepth[?ctx] < MaxMayContextDepth[].

/*
// Uses UNSOUND may-point-to, just for comparison during testing.
//// Has already stopped being useful, since it doesn't bind "this".
//// It even yields lower numbers than the sound rule.
PushMayContext[?invo,?ctx] = ?calleeCtx, MayContext(?calleeCtx),
MayCallGraphEdge:ToMethod(?toMeth, ?ctx, ?invo),
MayCallGraphEdge:Context[?ctx, ?invo] = ?calleeCtx <-
   VirtualMethodInvocation:Base[?invo] = ?heap,
   TypeResolvedVar(?heap),
   VPTTypeForVarModNull(?heaptype, ?heap),
   VirtualMethodInvocation:SimpleName[?invo] = ?simplename,
   VirtualMethodInvocation:Descriptor[?invo] = ?descriptor,
   MethodLookup[?simplename, ?descriptor, ?heaptype] = ?toMeth,
   MayContextDepth[?ctx] < MaxMayContextDepth[],
   Instruction:Method[?invo] = ?inMeth,
   ReachableMethodUnderMayContext(?ctx, ?inMeth).
*/

// args
MayPointTo(?hctx, ?heap, ?calleeCtx, ?formal) <-
   MayCallGraphEdge:ToMethod(?toMethod, ?callerCtx, ?invo),
   MayCallGraphEdge:Context[?callerCtx, ?invo] = ?calleeCtx,
   FormalParam[?index, ?toMethod] = ?formal,
   ActualParam[?index, ?invo] = ?actual,
   MayPointTo(?hctx, ?heap, ?callerCtx, ?actual).

ReturnValueOfCallAssignedTo(?callerCtx, ?to, ?calleeCtx, ?toMethod) <-
   MayCallGraphEdge:ToMethod(?toMethod, ?callerCtx, ?invo),
   MayCallGraphEdge:Context[?callerCtx, ?invo] = ?calleeCtx,
   AssignReturnValue[?invo] = ?to.

// return vals
MayPointTo(?hctx, ?heap, ?callerCtx, ?to) <-
   ReturnValueOfCallAssignedTo(?callerCtx, ?to, ?calleeCtx, ?toMethod),
   AllReturn:MayPointTo(?hctx, ?heap, ?calleeCtx, ?toMethod).


FirstInstructionOfMethod[?meth] = ?firstInsn <-
   OptInstructionFromMethodIndex[?meth, 1] = ?firstInsn,
   !IsJumpTarget(?firstInsn).

_OptFieldFromClass(?fld, ?class) <-
   FieldSignature:DeclaringClass[?fld] = ?class.

_OptThisVarOfConstructor(?method, ?this) <-
   MethodSignature:SimpleName[?method] = "<init>",
   ThisVar[?method] = ?this.

// Handle constructors and initialization to null. This is key:
// it initializes InstanceFieldMayPointTo inferences. Without these
// rules, there would be zero facts. All other rules require a prior
// InstanceFieldMayPointTo.
MayHeapContext(?hctx), EmptyHeapContext[] = ?hctx,
AllPredecessors:InstanceFieldMayPointTo
 (?hctx, ?nullHeap, ?fld, ?hctxBase, ?baseHeap, ?calleeCtx, ?firstInsn) <-
   _OptThisVarOfConstructor(?ctorMethod, ?this),
   FirstInstructionOfMethod[?ctorMethod] = ?firstInsn,
   MayPointTo(?hctxBase, ?baseHeap, ?calleeCtx, ?this),
   HeapAllocation:Type[?baseHeap] = ?heapType,
   _OptFieldFromClass(?fld, ?heapType),
   !FieldModifier(Modifier:static[], ?fld),
   FieldSignature:Type[?fld] = ?fldType,
   ReferenceType(?fldType),
   HeapAllocation:Null[] = ?nullHeap.

// initialize arrays to null at allocation
Temp4(?hctx, ?nullHeap, ?hctxArray, ?arrayHeap, ?ctx, ?insn),
MayHeapContext(?hctx), EmptyHeapContext[] = ?hctx,
ArrayIndexMayPointTo(?hctx, ?nullHeap, ?hctxArray, ?arrayHeap, ?ctx, ?insn) <-
   AssignHeapAllocation:Heap[?insn] = ?arrayHeap,
   HeapAllocation:Type[?arrayHeap] = ?type,
   ArrayType(?type),
   Instruction:Method[?insn] = ?inMeth,
   ReachableMethodUnderMayContext(?ctx, ?inMeth),
   HeapAllocation:Null[] = ?nullHeap,
   EmptyHeapContext[] = ?hctxArray.

/*
//// This is just a very expensive no-op. clinit methods never get called
//// directly, so whatever inferences we make never propagate elsewhere.
FirstInstructionOfReachableInitializer(?firstInsn, ?ctx, ?initMethod) <-
   ReachableMethodUnderMayContext(?ctx, ?initMethod),
   MethodSignature:SimpleName[?initMethod] = "<clinit>",
   FirstInstructionOfMethod[?initMethod] = ?firstInsn.

// Same for class initializers
MayHeapContext(?hctx), EmptyHeapContext[] = ?hctx,
AllPredecessors:StaticFieldMayPointTo(?hctx, ?nullHeap, ?fld, ?calleeCtx, ?firstInsn) <-
   FirstInstructionOfReachableInitializer(?firstInsn, ?calleeCtx, ?initMethod),
   MethodSignature:DeclaringType[?initMethod] = ?type,
   _OptFieldFromClass(?fld, ?type),
   FieldModifier(Modifier:static[], ?fld),
   FieldSignature:Type[?fld] = ?fldType,
   ReferenceType(?fldType),
   HeapAllocation:Null[] = ?nullHeap.
*/

// propagate (instance/static) field must-point-to info
AllPredecessors:InstanceFieldMayPointTo
 (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?calleeCtx, ?firstInsn) <-
   MayCallGraphEdge:ToMethod(?toMethod, ?callerCtx, ?invo),
   MayCallGraphEdge:Context[?callerCtx, ?invo] = ?calleeCtx,
   FirstInstructionOfMethod[?toMethod] = ?firstInsn,
   AllPredecessors:InstanceFieldMayPointTo
    (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?callerCtx, ?invo).

Temp1(?hctx, ?heap, ?fld, ?calleeCtx, ?firstInsn),
AllPredecessors:StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?calleeCtx, ?firstInsn) <-
   MayCallGraphEdge:ToMethod(?toMethod, ?callerCtx, ?invo),
   MayCallGraphEdge:Context[?callerCtx, ?invo] = ?calleeCtx,
   FirstInstructionOfMethod[?toMethod] = ?firstInsn,
   AllPredecessors:StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?callerCtx, ?invo).

AllPredecessors:ArrayIndexMayPointTo
 (?hctx, ?heap, ?hctxArray, ?arrayHeap, ?calleeCtx, ?firstInsn) <-
   MayCallGraphEdge:ToMethod(?toMethod, ?callerCtx, ?invo),
   MayCallGraphEdge:Context[?callerCtx, ?invo] = ?calleeCtx,
   FirstInstructionOfMethod[?toMethod] = ?firstInsn,
   AllPredecessors:ArrayIndexMayPointTo
    (?hctx, ?heap, ?hctxArray, ?arrayHeap, ?callerCtx, ?invo).

MayCallGraphEdge:ToMethodAndContext(?callerCtx, ?invo, ?calleeCtx, ?toMethod) <-
   MayCallGraphEdge:ToMethod(?toMethod, ?callerCtx, ?invo),
   MayCallGraphEdge:Context[?callerCtx, ?invo] = ?calleeCtx.

InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?callerCtx, ?invo) <-
   MayCallGraphEdge:ToMethodAndContext(?callerCtx, ?invo, ?calleeCtx, ?toMethod),
   AllReturn:InstanceFieldMayPointTo
    (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?calleeCtx, ?toMethod).

Temp2(?hctx, ?heap, ?fld, ?callerCtx, ?invo),
StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?callerCtx, ?invo) <-
   MayCallGraphEdge:ToMethodAndContext(?callerCtx, ?invo, ?calleeCtx, ?toMethod),
   AllReturn:StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?calleeCtx, ?toMethod).

ArrayIndexMayPointTo(?hctx, ?heap, ?hctxArray, ?arrayHeap, ?callerCtx, ?invo) <-
   MayCallGraphEdge:ToMethodAndContext(?callerCtx, ?invo, ?calleeCtx, ?toMethod),
   AllReturn:ArrayIndexMayPointTo
    (?hctx, ?heap, ?hctxArray, ?arrayHeap, ?calleeCtx, ?toMethod).

_OptStoreInstanceField:From(?insn, ?from) <-
   StoreInstanceField:From[?insn] = ?from.

_OptStoreInstanceField:Base(?insn, ?base) <-
   StoreInstanceField:Base[?insn] = ?base.

StoreFromVarMayPointTo(?hctx, ?heap, ?ctx, ?insn) <-
   MayPointTo(?hctx, ?heap, ?ctx, ?from),
   _OptStoreInstanceField:From(?insn, ?from).

StoreBaseMayPointTo(?hctx, ?heap, ?ctx, ?insn) <-
   MayPointTo(?hctx, ?heap, ?ctx, ?base),
   _OptStoreInstanceField:Base(?insn, ?base).

// store instructions, weak update: info gets *added* to previous. Can
// turn into strong with must info. Need to have
// InstanceFieldMayPointTo before the instruction. See also frame rules.
InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn) <-
   AllPredecessors:InstanceFieldMayPointTo(_, _, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn),
   StoreFromVarMayPointTo(?hctx, ?heap, ?ctx, ?insn),
   StoreBaseMayPointTo(?hctxBase, ?baseHeap, ?ctx, ?insn),
   FieldInstruction:Signature[?insn] = ?fld.

// load instructions
MayPointTo(?hctx, ?heap, ?ctx, ?to) <-
   LoadInstanceField:Base[?insn] = ?base,
   LoadInstanceField:To[?insn] = ?to,
   FieldInstruction:Signature[?insn] = ?fld,
   InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn),
   MayPointTo(?hctxBase, ?baseHeap, ?ctx, ?base).

_OptStoreStaticField:From(?insn, ?from) <-
   StoreStaticField:From[?insn] = ?from.

StaticStoreFromVarMayPointTo(?hctx, ?heap, ?ctx, ?insn) <-
   MayPointTo(?hctx, ?heap, ?ctx, ?from),
   _OptStoreStaticField:From(?insn, ?from).

// static store instructions. Strong update this time. No frame rule to
// carry on the original info.
StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn) <-
   FieldInstruction:Signature[?insn] = ?fld,
   StaticStoreFromVarMayPointTo(?hctx, ?heap, ?ctx, ?insn).

// static load instructions
Temp3(?hctx, ?heap, ?ctx, ?to),
MayPointTo(?hctx, ?heap, ?ctx, ?to) <-
   LoadStaticField:To[?insn] = ?to,
   FieldInstruction:Signature[?insn] = ?fld,
   StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn).

_OptMethodFromVar[?var] = ?method <-
   Var:DeclaringMethod(?var, ?method).

// Final static fields that must point to an object, at the end of a
// class initializer, cannot change in the future; thus, we can make
// closed-world assumptions about the field.
StaticFinalFieldMayPointTo(?hctx, ?heap, ?fld) <-
   AllReturn:StaticFieldMayPointTo(?hctx, ?heap, ?fld, InitialMayContext[], ?meth),
   MethodSignature:SimpleName[?meth] = "<clinit>",
   FieldModifier(Modifier:final[], ?fld).

_OptFieldInstruction:Signature(?insn, ?fld) <-
   FieldInstruction:Signature[?insn] = ?fld.

MayPointTo(?hctx, ?heap, ?ctx, ?to) <-
   LoadStaticField:To[?insn] = ?to,
   _OptFieldInstruction:Signature(?insn, ?fld),
   StaticFinalFieldMayPointTo(?hctx, ?heap, ?fld),
   _OptMethodFromVar[?to] = ?inMeth,
   ReachableMethodUnderMayContext(?ctx, ?inMeth).


// array loads and stores

_OptStoreArrayIndex:From(?insn, ?from) <-
   StoreArrayIndex:From[?insn] = ?from.

_OptStoreArrayIndex:Base(?insn, ?var) <-
   StoreArrayIndex:Base[?insn] = ?var.
   
ArrayStoreFromVarMayPointTo(?hctx, ?heap, ?ctx, ?insn) <-
   MayPointTo(?hctx, ?heap, ?ctx, ?from),
   _OptStoreArrayIndex:From(?insn, ?from).

ArrayStoreBaseMayPointTo(?hctxArray, ?arrayHeap, ?ctx, ?insn) <-
   MayPointTo(?hctxArray, ?arrayHeap, ?ctx, ?base),
   _OptStoreArrayIndex:Base(?insn, ?base).

// Just like instance field: need to know over-estimate to add more. Also
// frame rule (later) to propagate existing.
ArrayIndexMayPointTo(?hctx, ?heap, ?hctxArray, ?arrayHeap, ?ctx, ?insn) <-
   AllPredecessors:ArrayIndexMayPointTo(_, _, ?hctxArray, ?arrayHeap, ?ctx, ?insn),
   ArrayStoreFromVarMayPointTo(?hctx, ?heap, ?ctx, ?insn),
   ArrayStoreBaseMayPointTo(?hctxArray, ?arrayHeap, ?ctx, ?insn).

Temp5(?hctx, ?heap, ?ctx, ?to),
MayPointTo(?hctx, ?heap, ?ctx, ?to) <-
   LoadArrayIndex:Base[?insn] = ?base,
   LoadArrayIndex:To[?insn] = ?to,
   ArrayIndexMayPointTo(?hctx, ?heap, ?hctxArray, ?arrayHeap, ?ctx, ?insn),
   MayPointTo(?hctxArray, ?arrayHeap, ?ctx, ?base).


//// ====================================
//// Weakening rules

AllCtxMayPointToInMethod(?hctx, ?heap, ?var, ?method) <-
   MayPointTo(?hctx, ?heap, InitialMayContext[], ?var),
   _OptMethodFromVar[?var] = ?method.

MayPointTo(?hctx, ?heap, ?ctx, ?var) <-
   ReachableMethodUnderMayContext(?ctx, ?method),
   AllCtxMayPointToInMethod(?hctx, ?heap, ?var, ?method).

AllCtxInstanceFieldMayPointToInMethod
  (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?insn, ?method) <-
   InstanceFieldMayPointTo
    (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, InitialMayContext[], ?insn),
   Instruction:Method[?insn] = ?method.

InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn) <-
   ReachableMethodUnderMayContext(?ctx, ?method),
   AllCtxInstanceFieldMayPointToInMethod
    (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?insn, ?method).

StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn) <-
   Instruction:Method[?insn] = ?method,
   ReachableMethodUnderMayContext(?ctx, ?method),
   StaticFieldMayPointTo(?hctx, ?heap, ?fld, InitialMayContext[], ?insn).

AllCtxArrayIndexMayPointToInMethod(?hctx, ?heap, ?hctxArray, ?arrayHeap, ?insn, ?method) <-
   ArrayIndexMayPointTo(?hctx, ?heap, ?hctxArray, ?arrayHeap, InitialMayContext[], ?insn),
   Instruction:Method[?insn] = ?method.

ArrayIndexMayPointTo(?hctx, ?heap, ?hctxArray, ?arrayHeap, ?ctx, ?insn) <-
   ReachableMethodUnderMayContext(?ctx, ?method),
   AllCtxArrayIndexMayPointToInMethod(?hctx, ?heap, ?hctxArray, ?arrayHeap, ?insn, ?method).

//// ====================================
//// BEGIN frame rules

// TODO: also, for freshly allocated objects, it should be enough to have
//       instance field points-to information for one path. The object doesn't
//       exist in others. This needs escape reasoning? The object may come back
//       to the same program point through the other path.

// TODO: handle final fields? Don't see how, without must info.

InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn) <-
   AllPredecessors:InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn),
   (!MethodInvocation(?insn); IgnorableMethodInvocation(?insn)),
   (!StoreInstanceField:Insn(?insn); FieldInstruction:Signature[?insn] != ?fld).

// A stunning frame rule for sound-may: if we have an overapproximation of what the
// store instruction updates, then all past information on the same field can be kept.
InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn) <-
   AllPredecessors:InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn),
   StoreFromVarMayPointTo(_, _, ?ctx, ?insn),
   StoreBaseMayPointTo(_, _, ?ctx, ?insn),
   FieldInstruction:Signature[?insn] = ?fld.

StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn) <-
   AllPredecessors:StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn),
   (!MethodInvocation(?insn);
    IgnorableMethodInvocation(?insn);
	IgnorableMethodInvocationForStatic(?insn)),
   (!StoreStaticField:Insn(?insn); FieldInstruction:Signature[?insn] != ?fld).

// Note the *absence* of a frame rule to keep the old
// StaticFieldPointsTo information when the same field is
// updated. This yields strong updated for static fields.

// Much like instance fields
ArrayIndexMayPointTo(?hctx, ?heap, ?hctxArray, ?arrayHeap, ?ctx, ?insn) <-
   AllPredecessors:ArrayIndexMayPointTo(?hctx, ?heap, ?hctxArray, ?arrayHeap, ?ctx, ?insn),
   (!MethodInvocation(?insn); IgnorableMethodInvocation(?insn)),
   !StoreArrayIndex:Insn(?insn).

ArrayIndexMayPointTo(?hctx, ?heap, ?hctxArray, ?arrayHeap, ?ctx, ?insn) <-
   AllPredecessors:ArrayIndexMayPointTo(?hctx, ?heap, ?hctxArray, ?arrayHeap, ?ctx, ?insn),
   ArrayStoreFromVarMayPointTo(_, _, ?ctx, ?insn),
   ArrayStoreBaseMayPointTo(_, _, ?ctx, ?insn).


// Some calls to native or otherwise complex methods need to be
// modeled, i.e., ignored. E.g., fillInStackTrace is a native method
// called in the constructor of a (ubiquitous) java.lang.Throwable. If
// not ignored, no image of the heap propagates anywhere.
// TODO: do a better match (on full sig) than just on SimpleName.
IgnorableMethodInvocation(?invo) <-
   VirtualMethodInvocation:SimpleName[?invo] = "fillInStackTrace"; // Throwable
   VirtualMethodInvocation:SimpleName[?invo] = "equals";  // Object
   VirtualMethodInvocation:SimpleName[?invo] = "hashCode";
   VirtualMethodInvocation:SimpleName[?invo] = "toString";
   VirtualMethodInvocation:SimpleName[?invo] = "println"; // PrintStream
   StaticMethodInvocation:SimpleName[?invo] = "parseInt"; // Integer
   VirtualMethodInvocation:SimpleName[?invo] = "endsWith"; // String
   StaticMethodInvocation:SimpleName[?invo] = "floatToRawIntBits"; // Float
   // these are used in the HashMap "put" method!
   StaticMethodInvocation:SimpleName[?invo] = "intBitsToFloat"; 
   // From this point on, it's just a test to see if these natives matter.
   StaticMethodInvocation:SimpleName[?invo] = "encoding"; // Console
   StaticMethodInvocation:SimpleName[?invo] = "echo"; 
   StaticMethodInvocation:SimpleName[?invo] = "istty"; 
   VirtualMethodInvocation:SimpleName[?invo] = "sync"; // FileDescriptor
   StaticMethodInvocation:SimpleName[?invo] = "initIDs"; 
   VirtualMethodInvocation:SimpleName[?invo] = "open"; // FileInputStream
   VirtualMethodInvocation:SimpleName[?invo] = "read0"; 
   VirtualMethodInvocation:SimpleName[?invo] = "readBytes"; 
   VirtualMethodInvocation:SimpleName[?invo] = "skip"; 
   VirtualMethodInvocation:SimpleName[?invo] = "available"; 
   VirtualMethodInvocation:SimpleName[?invo] = "close0"; 
   VirtualMethodInvocation:SimpleName[?invo] = "write"; // FileOutputStream
   VirtualMethodInvocation:SimpleName[?invo] = "writeBytes"; 
   VirtualMethodInvocation:SimpleName[?invo] = "availableProcessors"; // Runtime
   VirtualMethodInvocation:SimpleName[?invo] = "freeMemory"; 
   VirtualMethodInvocation:SimpleName[?invo] = "totalMemory"; 
   VirtualMethodInvocation:SimpleName[?invo] = "maxMemory"; 
   VirtualMethodInvocation:SimpleName[?invo] = "gc"; 
   StaticMethodInvocation:SimpleName[?invo] = "runFinalization0"; 
   StaticMethodInvocation:SimpleName[?invo] = "sin"; // StrictMath
   StaticMethodInvocation:SimpleName[?invo] = "cos"; 
   StaticMethodInvocation:SimpleName[?invo] = "tan"; 
   StaticMethodInvocation:SimpleName[?invo] = "log"; 
   StaticMethodInvocation:SimpleName[?invo] = "pow";
   StaticMethodInvocation:SimpleName[?invo] = "currentThread"; // Thread
   StaticMethodInvocation:SimpleName[?invo] = "yield";
   StaticMethodInvocation:SimpleName[?invo] = "sleep";
   VirtualMethodInvocation:SimpleName[?invo] = "start0";
   VirtualMethodInvocation:SimpleName[?invo] = "isInterrupted";
   VirtualMethodInvocation:SimpleName[?invo] = "isAlive";
   StaticMethodInvocation:SimpleName[?invo] = "holdsLock";
   StaticMethodInvocation:SimpleName[?invo] = "getThreads";
   StaticMethodInvocation:SimpleName[?invo] = "dumpThreads";
   VirtualMethodInvocation:SimpleName[?invo] = "setPriority";
   VirtualMethodInvocation:SimpleName[?invo] = "stop0";
   VirtualMethodInvocation:SimpleName[?invo] = "suspend0";
   VirtualMethodInvocation:SimpleName[?invo] = "resume0";
   VirtualMethodInvocation:SimpleName[?invo] = "interrupt0";
   VirtualMethodInvocation:SimpleName[?invo] = "isAlive";
   VirtualMethodInvocation:SimpleName[?invo] = "getStackTraceDepth"; // Throwable
   VirtualMethodInvocation:SimpleName[?invo] = "getStackTraceElement"; 
   VirtualMethodInvocation:SimpleName[?invo] = "forkAndExec";  // UnixProcess
   VirtualMethodInvocation:SimpleName[?invo] = "wait"; // Object
   VirtualMethodInvocation:SimpleName[?invo] = "notify";
   VirtualMethodInvocation:SimpleName[?invo] = "notifyAll".

IgnorableMethodInvocationForStatic(?invo) <-
   VirtualMethodInvocation:SimpleName[?invo] = "intern"; // String
   VirtualMethodInvocation:SimpleName[?invo] = "clone"; // Object
   VirtualMethodInvocation:SimpleName[?invo] = "append". // StringBuilder

StaticMethodInvocation:SimpleName[?invocation] = ?simplename <-
   MethodInvocation:Signature[?invocation] = ?signature,
   StaticMethodInvocation:Insn(?invocation),
   MethodSignature:SimpleName[?signature] = ?simplename.

/*
//// Unsound HACK! Just during testing, for estimating the impact of
//// better "NonDom" logic.
AllPredecessors:InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn) <-
   AllNonDomPredecessors:InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn).
AllPredecessors:StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn) <-
   AllNonDomPredecessors:StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn).
AllPredecessors:ArrayIndexMayPointTo(?hctx, ?heap, ?hctxArray, ?arrayHeap, ?ctx, ?insn) <-
   AllNonDomPredecessors:ArrayIndexMayPointTo(?hctx, ?heap, ?hctxArray, ?arrayHeap, ?ctx, ?insn).
*/



/*
//// TODO
//// ====================================
//// Logic for computing the highly useful concepts of "Method/Call
//// Does Not Invalidate Field"

MethodDirectlyInvalidatesField(?fld, ?inMeth) <-
   FieldInstruction:Signature[?insn] = ?fld,
   Instruction:Method[?insn] = ?inMeth.

OptInvocationInsn(?insn, ?method) <-
   Instruction:Method[?insn] = ?method,
   MethodInvocation(?insn).

HigherIndexInvocationInMethod(?invo, ?indexHigher) <-
   OptInvocationInsn(?invo, ?inMeth),
   OptInvocationInsn(?higherInvo, ?inMeth),
   Instruction:Index[?higherInvo] = ?indexHigher,
   Instruction:Index[?invo] < ?indexHigher.   
   
NextInvocationInMethod[?invo] = ?nextInvo <-
   agg<<?nextInvo = 
      min(?index)>>(HigherIndexInvocationInMethod(?invo, ?index)).

DefiniteInvocation[?invo] = ?toMethod <-
   (SpecialMethodInvocation:Insn(?invo);
    StaticMethodInvocation:Insn(?invo)),
   MethodInvocation:Signature[?invo] = ?toMethod.

MethodCallsUnknown(?method) <-
   Instruction:Method[?insn] = ?method,
   VirtualMethodInvocation:Insn(?insn).

MethodHasCalls(?method) <-
   OptInvocationInsn(_, ?method).
   
AllMethodCallsDefinite(?method) <-
   MethodHasCalls(?method),
   !MethodCallsUnknown(?method).
*/ 




/*
// TODO: currently has no impact. Comment out and re-check when non-invalidating
//       method calls are added?

// Interesting addition to frame rules:
// propagate in case of non-invalidating dominated predecessors.

BasicBlockMayInvalidateFieldPointsTo(?fld, ?headInsn) <-
   BasicBlockHead[?insn] = ?headInsn,
   FieldInstruction:Signature[?insn] = ?fld.

// The path (dominated by ?dominator) that ends at ?insn
// may invalidate some field.
DominatedPathMayInvalidateFieldPointsTo(?fld, ?insn, ?dominator) <-
   Dominates(?dominator, ?insn),
   BasicBlockMayInvalidateFieldPointsTo(?fld, ?insn).

DominatedPathMayInvalidateFieldPointsTo(?fld, ?insn, ?dominator) <-
   DominatedPathMayInvalidateFieldPointsTo(?fld, ?otherInsn, ?dominator),
   MaySuccessorBBModuloThrow(?insn, ?otherInsn),
   Dominates(?dominator, ?insn).

ExistsFieldInvalidatingPathToPredecessor(?fld, ?prevHead, ?dominator) <-
   DominatesItsPredecessorInstruction(?prevInsn, ?dominator),
   BasicBlockHead[?prevInsn] = ?prevHead,
   DominatedPathMayInvalidateFieldPointsTo(?fld, ?prevHead, ?dominator).

ExistsFieldInvalidatingPathToSomePredecessor(?fld, ?dominator) <-
   ExistsFieldInvalidatingPathToPredecessor(?fld, _, ?dominator).

BasicBlockMayInvalidateAllFieldsPointsTo(?headInsn) <-
   BasicBlockHead[?insn] = ?headInsn,
   !IndifferentInstruction(?insn),
   !FieldInstruction(?insn).

// The path (dominated by ?dominator) that ends at ?insn
// may invalidate any field.
DominatedPathMayInvalidateAllFieldsPointsTo(?insn, ?dominator) <-
   Dominates(?dominator, ?insn),
   BasicBlockMayInvalidateAllFieldsPointsTo(?insn).

DominatedPathMayInvalidateAllFieldsPointsTo(?insn, ?dominator) <-
   DominatedPathMayInvalidateAllFieldsPointsTo(?otherInsn, ?dominator),
   MaySuccessorBBModuloThrow(?insn, ?otherInsn),
   Dominates(?dominator, ?insn).

ExistsAllFieldsInvalidatingPathToPredecessor(?prevHead, ?dominator) <-
   DominatesItsPredecessorInstruction(?prevInsn, ?dominator),
   BasicBlockHead[?prevInsn] = ?prevHead,
   DominatedPathMayInvalidateAllFieldsPointsTo(?prevHead, ?dominator).

ExistsAllFieldsInvalidatingPathToSomePredecessor(?dominator) <-
   ExistsAllFieldsInvalidatingPathToPredecessor(_, ?dominator).

InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn) <-
   AllNonDomPredecessors:InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn),
   !ExistsFieldInvalidatingPathToSomePredecessor(?fld, ?insn),
   !ExistsAllFieldsInvalidatingPathToSomePredecessor(?insn),
   DominatesItsPredecessorInstruction(_, ?insn).

StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn) <-
   AllNonDomPredecessors:StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn),
   !ExistsFieldInvalidatingPathToSomePredecessor(?fld, ?insn),
   !ExistsAllFieldsInvalidatingPathToSomePredecessor(?insn),
   DominatesItsPredecessorInstruction(_, ?insn).

// TODO: update with arrays
*/


//// END frame rules

//// ====================================
//// BEGIN context management

// Heap contexts
MayHeapContext(?hctx) ->.
lang:entity(`MayHeapContext).
lang:physical:storageModel[`MayHeapContext]="ScalableSparse".
lang:physical:capacity[`MayHeapContext] = 8388608.

EmptyHeapContext[] = ?hctx -> MayHeapContext(?hctx).
lang:skolem(`EmptyHeapContext).
EmptyHeapContext[] = ?hctx, MayHeapContext(?hctx)  <- .

// #define RecordMacroMay(ctx,heap,hctx) \
//   MayHeapContext(hctx), \
//   EmptyHeapContext[] = hctx


// Calling contexts
MayContext(?ctx) ->.
lang:entity(`MayContext).
lang:physical:storageModel[`MayContext]="ScalableSparse".
lang:physical:capacity[`MayContext] = 2147483648.

InitialMayContext[] = ?ctx -> MayContext(?ctx).
lang:skolem(`InitialMayContext).
InitialMayContext[] = ?ctx, MayContext(?ctx)  <- .

PushMayContext[?invo, ?ctx] = ?pushedCtx ->
   MayContext(?pushedCtx), MayContext(?ctx), CallGraphEdgeSource(?invo).
lang:skolem(`PushMayContext).
PopMayContext[?ctx] = ?poppedCtx ->
   MayContext(?poppedCtx), MayContext(?ctx).
PopMayContext[?ctx] = ?poppedCtx <-
   PushMayContext[_, ?poppedCtx] = ?ctx.

InvoFromMayContext[?ctx] = ?invocation ->
   MayContext(?ctx), CallGraphEdgeSource(?invocation).
InvoFromMayContext[?ctx] = ?invocation <- 
   PushMayContext[?invocation, _] = ?ctx.

MayContextDepth[?ctx] = ?depth ->
   MayContext(?ctx), int[32](?depth).
MayContextDepth[?ctx] = ?depth+1 <-
   PushMayContext[_, ?poppedCtx] = ?ctx,
   MayContextDepth[?poppedCtx] = ?depth.
MayContextDepth[?ctx] = 0 <-
   InitialMayContext[] = ?ctx.

MaxMayContextDepth[] = ?num -> int[32](?num).

//// END context management


//// ====================================
//// BEGIN configuration
////  Different ways to kick-start the analysis.

RootMethodForMayAnalysis(?meth) <-
   MethodSignature:DeclaringType[?meth] = ?class, ApplicationClass(?class).

// Try to discover hidden "main" heuristically
AppMainMethod(?mainMeth) <-
   MethodSignature:SimpleName[?mainMeth] = "main",
   MethodSignature:DeclaringType[?mainMeth] = ?class,
   ApplicationClass(?class).

// Heuristic: if you can reach it in the analysis and it's a static
// initializer, start a new search (with zero context depth) from it.
// There are lots of static final fields in the library that see heavy
// use.
ClinitMethodOfClass(?meth, ?class) <-
   MethodSignature:SimpleName[?meth] = "<clinit>",
   MethodSignature:DeclaringType[?meth] = ?class.
   
RootMethodForMayAnalysis(?clinitMeth) <-
   ReachableMethodUnderMayContext(_, ?meth),
   MethodSignature:DeclaringType[?meth] = ?class,
   ClinitMethodOfClass(?clinitMeth, ?class).

/*
RootMethodForMayAnalysis(?clinitMeth) <-
   ReachableMethodUnderMayContext(_, ?meth).
*/

/*
RootMethodForMayAnalysis(?meth) <-
   AppMainMethod(?meth).

// Heuristic: if you can reach it in the analysis and it's an app
// method, start a new search (with zero context depth) from it.
RootMethodForMayAnalysis(?meth) <-
   ReachableMethodUnderMayContext(_, ?meth),
   MethodSignature:DeclaringType[?meth] = ?class,
   ApplicationClass(?class).
*/


// For the legit, official main of a standard Java program, provide
// dummy argument (String[] args).
MayPointTo(?hctx, ?argsArray, ?ctx, ?args),
AllPredecessors:ArrayIndexMayPointTo(?hctx, ?argHeap, ?hctx, ?argsArray, ?ctx, ?firstInsn) <-
   MainClass(?mainClass),
   MethodSignature:DeclaringType[?mainMethod] = ?mainClass,
   ReachableMethodUnderMayContext(?ctx, ?mainMethod),
   MethodSignature:Descriptor[?mainMethod] = "void(java.lang.String[])",
   FormalParam[0, ?mainMethod] = ?args,
   MainMethodArgsArray(?argsArray),
   MainMethodArgHeap(?argHeap),
   ?hctx = EmptyHeapContext[],
   FirstInstructionOfMethod[?mainMethod] = ?firstInsn.


// At the beginning of "main", all static fields of classes are
// assumed to point to null. This is sound (even though <clinit>s will
// be called whenever)!  It is an overestimate of what's true.
StaticFieldOfMayReachableClass(?fld) <-
   ReachableMethodUnderMayContext(_, ?meth),
   MethodSignature:DeclaringType[?meth] = ?class,
//   ApplicationClass(?class),
   _OptFieldFromClass(?fld, ?class),
   FieldModifier(Modifier:static[], ?fld),
   FieldSignature:Type[?fld] = ?fldType,
   ReferenceType(?fldType).

MayHeapContext(?hctx), EmptyHeapContext[] = ?hctx,
AllPredecessors:StaticFieldMayPointTo(?hctx, ?nullHeap, ?fld, InitialMayContext[], ?firstInsn) <-
//   MainMethodDeclaration(?mainMeth),
   AppMainMethod(?mainMeth),
   FirstInstructionOfMethod[?mainMeth] = ?firstInsn,
   StaticFieldOfMayReachableClass(?fld),
   HeapAllocation:Null[] = ?nullHeap.


MaxMayContextDepth[] = 10 <- .

//// END configuration


//// ====================================
//// AUXILIARY. Helper relations, "forall" emulations.

// For all Phi node instructions, the "to" var (implicit in the
// predicate) may point to...
MayPointToUpToPhiInstruction(?hctx, ?heap, ?ctx, ?insn) ->
   MayHeapContext(?hctx), HeapAllocation(?heap), MayContext(?ctx), 
   Instruction(?insn).

MayPointToUpToPhiInstruction(?hctx, ?heap, ?ctx, ?headInsn) <-
   PhiNodeHead[_] = ?headInsn,
   AssignLocal:From[?headInsn] = ?from,
   MayPointTo(?hctx, ?heap, ?ctx, ?from).

MayPointToUpToPhiInstruction(?hctx1, ?heap1, ?ctx, ?nextInsn),
MayPointToUpToPhiInstruction(?hctx2, ?heap2, ?ctx, ?nextInsn) <-
   MayPointToUpToPhiInstruction(?hctx1, ?heap1, ?ctx, ?insn),
   NextInSamePhiNode[?insn] = ?nextInsn,
   AssignLocal:From[?nextInsn] = ?from,
   MayPointTo(?hctx2, ?heap2, ?ctx, ?from).

// for all returns of a method, the return variable has a known upper bound
// for its points-to, and we take the union of all such bounds
UpToReturnMayPointTo(?hctx, ?heap, ?ctx, ?return) <-
   ReturnInstruction(?return),
   !ExistsPreviousReturn(?return),
   ReturnNonvoid:Var[?return] = ?var,
   MayPointTo(?hctx, ?heap, ?ctx, ?var).

UpToReturnMayPointTo(?hctx1, ?heap1, ?ctx, ?return),
UpToReturnMayPointTo(?hctx2, ?heap2, ?ctx, ?return) <-
   UpToReturnMayPointTo(?hctx1, ?heap1, ?ctx, ?prevReturn),
   NextReturn[?prevReturn] = ?return,
   ReturnNonvoid:Var[?return] = ?var,
   MayPointTo(?hctx2, ?heap2, ?ctx, ?var).

AllReturn:MayPointTo(?hctx, ?heap, ?ctx, ?method) <-
   UpToReturnMayPointTo(?hctx, ?heap, ?ctx, ?return),
   !(NextReturn[?return] = _),
   Instruction:Method[?return] = ?method.

/// ----------------------------------


/// InstanceFieldMayPointTo for predecessors

// Up to a certain non-dominated predecessor basic block, there is
// instance field point-to information. We take the union.
InstanceFieldMayPointToUpToNonDomPredecessor(?hctx, ?heap, ?fld, ?hctxBase,
                                             ?baseHeap, ?ctx, ?insn, ?pred) ->
   MayHeapContext(?hctx), HeapAllocation(?heap),
   FieldSignature(?fld), MayHeapContext(?hctxBase),
   HeapAllocation(?baseHeap), MayContext(?ctx), Instruction(?insn), Instruction(?pred).

InstanceFieldMayPointToUpToNonDomPredecessor(?hctx, ?heap, ?fld, ?hctxBase,
                                             ?baseHeap, ?ctx, ?insn, ?pred) <-
   MaySuccessorBBModuloThrow(?insn, ?pred),
   BasicBlockEnd(?tail),
   BasicBlockHead[?tail] = ?pred,
   InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?tail),
   !ExistsPreviousNonDomPredecessorToSameBB(?pred, ?insn).

OptInstanceFieldMayPointToAtNextNonDomPredecessor
 (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn, ?predPrev) <-
   BasicBlockEnd(?tail),
   BasicBlockHead[?tail] = ?pred,
   InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?tail),
   PreviousNonDomPredecessorToSameBB[?insn, ?pred] = ?predPrev.

InstanceFieldMayPointToUpToNonDomPredecessor
 (?hctx1, ?heap1, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn, ?pred),
InstanceFieldMayPointToUpToNonDomPredecessor
 (?hctx2, ?heap2, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn, ?pred) <-
   InstanceFieldMayPointToUpToNonDomPredecessor
    (?hctx1, ?heap1, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn, ?prevPred),
   OptInstanceFieldMayPointToAtNextNonDomPredecessor
    (?hctx2, ?heap2, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn, ?prevPred),
   NextNonDomPredecessorToSameBB[?insn, ?prevPred] = ?pred.

// For all non-dominated predecessor instructions, there is point-to information.
// We take the union.
AllNonDomPredecessors:InstanceFieldMayPointTo
 (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn) ->
   MayHeapContext(?hctx), HeapAllocation(?heap),
   FieldSignature(?fld), MayHeapContext(?hctxBase),
   HeapAllocation(?baseHeap), MayContext(?ctx), Instruction(?insn).
   
AllNonDomPredecessors:InstanceFieldMayPointTo
 (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn) <-
   InstanceFieldMayPointToUpToNonDomPredecessor
    (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn, ?pred),
   !(NextNonDomPredecessorToSameBB[?insn, ?pred] = _),
   !ExceptionHandlerFirstInstruction(?insn).

AllNonDomPredecessors:InstanceFieldMayPointTo
 (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn) <-
   PrevInSameBasicBlock[?insn] = ?prev,
   InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?prev).


// Same as above, for all predecessors (not just non-dominated ones)

// Up to a certain predecessor basic block, there is
// instance field point-to information. We take the union.
InstanceFieldMayPointToUpToPredecessor(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap,
                                       ?ctx, ?insn, ?pred) ->
   MayHeapContext(?hctx), HeapAllocation(?heap),
   FieldSignature(?fld), MayHeapContext(?hctxBase),
   HeapAllocation(?baseHeap), MayContext(?ctx), Instruction(?insn), Instruction(?pred).

InstanceFieldMayPointToUpToPredecessor(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap,
                                       ?ctx, ?insn, ?pred) <-
   MaySuccessorBBModuloThrow(?insn, ?pred),
   BasicBlockEnd(?tail),
   BasicBlockHead[?tail] = ?pred,
   InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?tail),
   !ExistsPreviousPredecessorToSameBB(?pred, ?insn).

OptInstanceFieldMayPointToAtNextPredecessor
 (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn, ?predPrev) <-
   BasicBlockEnd(?tail),
   BasicBlockHead[?tail] = ?pred,
   InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?tail),
   PreviousPredecessorToSameBB[?insn, ?pred] = ?predPrev.

InstanceFieldMayPointToUpToPredecessor
 (?hctx1, ?heap1, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn, ?pred),
InstanceFieldMayPointToUpToPredecessor
 (?hctx2, ?heap2, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn, ?pred) <-
   InstanceFieldMayPointToUpToPredecessor
    (?hctx1, ?heap1, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn, ?prevPred),
   OptInstanceFieldMayPointToAtNextPredecessor
    (?hctx2, ?heap2, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn, ?prevPred),
   NextPredecessorToSameBB[?insn, ?prevPred] = ?pred.

// For all predecessor instructions, there is point-to information.
// We take the union.
AllPredecessors:InstanceFieldMayPointTo
 (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn) ->
   MayHeapContext(?hctx), HeapAllocation(?heap),
   FieldSignature(?fld), MayHeapContext(?hctxBase),
   HeapAllocation(?baseHeap), MayContext(?ctx), Instruction(?insn).
   
AllPredecessors:InstanceFieldMayPointTo
 (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn) <-
   InstanceFieldMayPointToUpToPredecessor
    (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn, ?pred),
   !(NextPredecessorToSameBB[?insn, ?pred] = _),
   !ExceptionHandlerFirstInstruction(?insn).

AllPredecessors:InstanceFieldMayPointTo
 (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn) <-
   PrevInSameBasicBlock[?insn] = ?prev,
   InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?prev).

/// ----------------------------------


/// StaticFieldMayPointTo for predecessors

// Up to a certain non-dominated predecessor basic block, there is
// static field point-to information. We take the union.
StaticFieldMayPointToUpToNonDomPredecessor(?hctx, ?heap, ?fld, ?ctx, ?insn, ?pred) ->
   MayHeapContext(?hctx), HeapAllocation(?heap),
   FieldSignature(?fld), MayContext(?ctx), Instruction(?insn), Instruction(?pred).

StaticFieldMayPointToUpToNonDomPredecessor(?hctx, ?heap, ?fld, ?ctx, ?insn, ?pred) <-
   MaySuccessorBBModuloThrow(?insn, ?pred),
   BasicBlockEnd(?tail),
   BasicBlockHead[?tail] = ?pred,
   StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?tail),
   !ExistsPreviousNonDomPredecessorToSameBB(?pred, ?insn).

OptStaticFieldMayPointToAtNextNonDomPredecessor(?hctx, ?heap, ?fld, ?ctx, ?insn, ?predPrev) <-
   BasicBlockEnd(?tail),
   BasicBlockHead[?tail] = ?pred,
   StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?tail),
   PreviousNonDomPredecessorToSameBB[?insn, ?pred] = ?predPrev.

StaticFieldMayPointToUpToNonDomPredecessor(?hctx1, ?heap1, ?fld, ?ctx, ?insn, ?pred),
StaticFieldMayPointToUpToNonDomPredecessor(?hctx2, ?heap2, ?fld, ?ctx, ?insn, ?pred) <-
   StaticFieldMayPointToUpToNonDomPredecessor
    (?hctx1, ?heap1, ?fld, ?ctx, ?insn, ?prevPred),
   OptStaticFieldMayPointToAtNextNonDomPredecessor
    (?hctx2, ?heap2, ?fld, ?ctx, ?insn, ?prevPred),
   NextNonDomPredecessorToSameBB[?insn, ?prevPred] = ?pred.

// For all non-dominated predecessor instructions, there is point-to information.
// We take the union.
AllNonDomPredecessors:StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn) ->
   MayHeapContext(?hctx), HeapAllocation(?heap),
   FieldSignature(?fld), MayContext(?ctx), Instruction(?insn).
   
AllNonDomPredecessors:StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn) <-
   StaticFieldMayPointToUpToNonDomPredecessor(?hctx, ?heap, ?fld, ?ctx, ?insn, ?pred),
   !(NextNonDomPredecessorToSameBB[?insn, ?pred] = _),
   !ExceptionHandlerFirstInstruction(?insn).

AllNonDomPredecessors:StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn) <-
   PrevInSameBasicBlock[?insn] = ?prev,
   StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?prev).


// Same as above, for all predecessors (not just non-dominated ones)

// Up to a certain predecessor basic block, there is
// static field point-to information. We take the union.
StaticFieldMayPointToUpToPredecessor(?hctx, ?heap, ?fld, ?ctx, ?insn, ?pred) ->
   MayHeapContext(?hctx), HeapAllocation(?heap),
   FieldSignature(?fld), MayContext(?ctx), Instruction(?insn), Instruction(?pred).

StaticFieldMayPointToUpToPredecessor(?hctx, ?heap, ?fld, ?ctx, ?insn, ?pred) <-
   MaySuccessorBBModuloThrow(?insn, ?pred),
   BasicBlockEnd(?tail),
   BasicBlockHead[?tail] = ?pred,
   StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?tail),
   !ExistsPreviousPredecessorToSameBB(?pred, ?insn).

OptStaticFieldMayPointToAtNextPredecessor
      (?hctx, ?heap, ?fld, ?ctx, ?insn, ?predPrev) <-
   BasicBlockEnd(?tail),
   BasicBlockHead[?tail] = ?pred,
   StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?tail),
   PreviousPredecessorToSameBB[?insn, ?pred] = ?predPrev.

StaticFieldMayPointToUpToPredecessor(?hctx1, ?heap1, ?fld, ?ctx, ?insn, ?pred),
StaticFieldMayPointToUpToPredecessor(?hctx2, ?heap2, ?fld, ?ctx, ?insn, ?pred) <-
   StaticFieldMayPointToUpToPredecessor
    (?hctx1, ?heap1, ?fld, ?ctx, ?insn, ?prevPred),
   OptStaticFieldMayPointToAtNextPredecessor
    (?hctx2, ?heap2, ?fld, ?ctx, ?insn, ?prevPred),
   NextPredecessorToSameBB[?insn, ?prevPred] = ?pred.

// For all predecessor instructions, there is point-to information.
// We take the union.
AllPredecessors:StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn) ->
   MayHeapContext(?hctx), HeapAllocation(?heap),
   FieldSignature(?fld), MayContext(?ctx), Instruction(?insn).
   
AllPredecessors:StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn) <-
   StaticFieldMayPointToUpToPredecessor
    (?hctx, ?heap, ?fld, ?ctx, ?insn, ?pred),
   !(NextPredecessorToSameBB[?insn, ?pred] = _),
   !ExceptionHandlerFirstInstruction(?insn).

AllPredecessors:StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn) <-
   PrevInSameBasicBlock[?insn] = ?prev,
   StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?prev).


/// ----------------------------------


/// ArrayIndexMayPointTo for predecessors

// Up to a certain non-dominated predecessor basic block, there is
// array-index points-to information. We take the union of all such sets.
ArrayIndexMayPointToUpToNonDomPredecessor(?hctx, ?heap, ?hctxArray,
                                          ?arrayHeap, ?ctx, ?insn, ?pred) ->
   MayHeapContext(?hctx), HeapAllocation(?heap),
   MayHeapContext(?hctxArray), HeapAllocation(?arrayHeap),
   MayContext(?ctx), Instruction(?insn), Instruction(?pred).

ArrayIndexMayPointToUpToNonDomPredecessor(?hctx, ?heap, ?hctxArray,
                                          ?arrayHeap, ?ctx, ?insn, ?pred) <-
   MaySuccessorBBModuloThrow(?insn, ?pred),
   BasicBlockEnd(?tail),
   BasicBlockHead[?tail] = ?pred,
   ArrayIndexMayPointTo(?hctx, ?heap, ?hctxArray, ?arrayHeap, ?ctx, ?tail),
   !ExistsPreviousNonDomPredecessorToSameBB(?pred, ?insn).

OptArrayIndexMayPointToAtNextNonDomPredecessor
      (?hctx, ?heap, ?hctxArray, ?arrayHeap, ?ctx, ?insn, ?predPrev) <-
   BasicBlockEnd(?tail),
   BasicBlockHead[?tail] = ?pred,
   ArrayIndexMayPointTo(?hctx, ?heap, ?hctxArray, ?arrayHeap, ?ctx, ?tail),
   PreviousNonDomPredecessorToSameBB[?insn, ?pred] = ?predPrev.

ArrayIndexMayPointToUpToNonDomPredecessor
 (?hctx1, ?heap1, ?hctxArray, ?arrayHeap, ?ctx, ?insn, ?pred),
ArrayIndexMayPointToUpToNonDomPredecessor
 (?hctx2, ?heap2, ?hctxArray, ?arrayHeap, ?ctx, ?insn, ?pred) <-
   ArrayIndexMayPointToUpToNonDomPredecessor
    (?hctx1, ?heap1, ?hctxArray, ?arrayHeap, ?ctx, ?insn, ?prevPred),
   OptArrayIndexMayPointToAtNextNonDomPredecessor
    (?hctx2, ?heap2, ?hctxArray, ?arrayHeap, ?ctx, ?insn, ?prevPred),
   NextNonDomPredecessorToSameBB[?insn, ?prevPred] = ?pred.

// For all non-dominated predecessor instructions, there is point-to information.
// We take the union.
AllNonDomPredecessors:ArrayIndexMayPointTo(
      ?hctx, ?heap, ?hctxArray, ?arrayHeap, ?ctx, ?insn) ->
   MayHeapContext(?hctx), HeapAllocation(?heap),
   MayHeapContext(?hctxArray), HeapAllocation(?arrayHeap),
   MayContext(?ctx), Instruction(?insn).
   
AllNonDomPredecessors:ArrayIndexMayPointTo
 (?hctx, ?heap, ?hctxArray, ?arrayHeap, ?ctx, ?insn) <-
   ArrayIndexMayPointToUpToNonDomPredecessor
    (?hctx, ?heap, ?hctxArray, ?arrayHeap, ?ctx, ?insn, ?pred),
   !(NextNonDomPredecessorToSameBB[?insn, ?pred] = _),
   !ExceptionHandlerFirstInstruction(?insn).

AllNonDomPredecessors:ArrayIndexMayPointTo
 (?hctx, ?heap, ?hctxArray, ?arrayHeap, ?ctx, ?insn) <-
   PrevInSameBasicBlock[?insn] = ?prev,
   ArrayIndexMayPointTo(?hctx, ?heap, ?hctxArray, ?arrayHeap, ?ctx, ?prev).


// Same as above, for all predecessors (not just non-dominated ones)

// Up to a certain predecessor basic block, there is
// array-index points-to information. We take the union.
ArrayIndexMayPointToUpToPredecessor(?hctx, ?heap, ?hctxArray, ?arrayHeap,
                                    ?ctx, ?insn, ?pred) ->
   MayHeapContext(?hctx), HeapAllocation(?heap),
   MayHeapContext(?hctxArray), HeapAllocation(?arrayHeap),
   MayContext(?ctx), Instruction(?insn), Instruction(?pred).

ArrayIndexMayPointToUpToPredecessor(?hctx, ?heap, ?hctxArray, ?arrayHeap,
                                    ?ctx, ?insn, ?pred) <-
   MaySuccessorBBModuloThrow(?insn, ?pred),
   BasicBlockEnd(?tail),
   BasicBlockHead[?tail] = ?pred,
   ArrayIndexMayPointTo(?hctx, ?heap, ?hctxArray, ?arrayHeap, ?ctx, ?tail),
   !ExistsPreviousPredecessorToSameBB(?pred, ?insn).

OptArrayIndexMayPointToAtNextPredecessor
 (?hctx, ?heap, ?hctxArray, ?arrayHeap, ?ctx, ?insn, ?predPrev) <-
   BasicBlockEnd(?tail),
   BasicBlockHead[?tail] = ?pred,
   ArrayIndexMayPointTo(?hctx, ?heap, ?hctxArray, ?arrayHeap, ?ctx, ?tail),
   PreviousPredecessorToSameBB[?insn, ?pred] = ?predPrev.

ArrayIndexMayPointToUpToPredecessor
 (?hctx1, ?heap1, ?hctxArray, ?arrayHeap, ?ctx, ?insn, ?pred),
ArrayIndexMayPointToUpToPredecessor
 (?hctx2, ?heap2, ?hctxArray, ?arrayHeap, ?ctx, ?insn, ?pred) <-
   ArrayIndexMayPointToUpToPredecessor
    (?hctx1, ?heap1, ?hctxArray, ?arrayHeap, ?ctx, ?insn, ?prevPred),
   OptArrayIndexMayPointToAtNextPredecessor
    (?hctx2, ?heap2, ?hctxArray, ?arrayHeap, ?ctx, ?insn, ?prevPred),
   NextPredecessorToSameBB[?insn, ?prevPred] = ?pred.

// For all predecessor instructions, there is point-to information.
// We take the union.
AllPredecessors:ArrayIndexMayPointTo(?hctx, ?heap, ?hctxArray, ?arrayHeap, ?ctx, ?insn) ->
   MayHeapContext(?hctx), HeapAllocation(?heap),
   MayHeapContext(?hctxArray), HeapAllocation(?arrayHeap),
   MayContext(?ctx), Instruction(?insn).
   
AllPredecessors:ArrayIndexMayPointTo(?hctx, ?heap, ?hctxArray, ?arrayHeap, ?ctx, ?insn) <-
   ArrayIndexMayPointToUpToPredecessor
    (?hctx, ?heap, ?hctxArray, ?arrayHeap, ?ctx, ?insn, ?pred),
   !(NextPredecessorToSameBB[?insn, ?pred] = _),
   !ExceptionHandlerFirstInstruction(?insn).

AllPredecessors:ArrayIndexMayPointTo(?hctx, ?heap, ?hctxArray, ?arrayHeap, ?ctx, ?insn) <-
   PrevInSameBasicBlock[?insn] = ?prev,
   ArrayIndexMayPointTo(?hctx, ?heap, ?hctxArray, ?arrayHeap, ?ctx, ?prev).

/// ----------------------------------


// for all returns of a method, a certain object+field points to known sets.
// We take their union.
UpToReturnInstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?return) <-
   ReturnInstruction(?return),
   !ExistsPreviousReturn(?return),
   AllPredecessors:InstanceFieldMayPointTo
    (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?return).

UpToReturnInstanceFieldMayPointTo(?hctx1, ?heap1, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?return),
UpToReturnInstanceFieldMayPointTo(?hctx2, ?heap2, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?return) <-
   UpToReturnInstanceFieldMayPointTo(?hctx2, ?heap2, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?prevReturn),
   NextReturn[?prevReturn] = ?return,
   AllPredecessors:InstanceFieldMayPointTo
    (?hctx1, ?heap1, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?return).

AllReturn:InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?method) <-
   UpToReturnInstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?return),
   !(NextReturn[?return] = _),
   Instruction:Method[?return] = ?method.


// for all returns of a method, a certain static field points to known sets.
// We take their union.
UpToReturnStaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?return) <-
   ReturnInstruction(?return),
   !ExistsPreviousReturn(?return),
   AllPredecessors:StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?return).

UpToReturnStaticFieldMayPointTo(?hctx1, ?heap1, ?fld, ?ctx, ?return),
UpToReturnStaticFieldMayPointTo(?hctx2, ?heap2, ?fld, ?ctx, ?return) <-
   UpToReturnStaticFieldMayPointTo(?hctx2, ?heap2, ?fld, ?ctx, ?prevReturn),
   NextReturn[?prevReturn] = ?return,
   AllPredecessors:StaticFieldMayPointTo(?hctx1, ?heap1, ?fld, ?ctx, ?return).

AllReturn:StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?method) <-
   UpToReturnStaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?return),
   !(NextReturn[?return] = _),
   Instruction:Method[?return] = ?method.


// for all returns of a method, an array, at *any* index points to known sets.
// We take their union.
UpToReturnArrayIndexMayPointTo(?hctx, ?heap, ?hctxArray, ?arrayHeap, ?ctx, ?return) <-
   ReturnInstruction(?return),
   !ExistsPreviousReturn(?return),
   AllPredecessors:ArrayIndexMayPointTo
    (?hctx, ?heap, ?hctxArray, ?arrayHeap, ?ctx, ?return).

UpToReturnArrayIndexMayPointTo(?hctx1, ?heap1, ?hctxArray, ?arrayHeap, ?ctx, ?return),
UpToReturnArrayIndexMayPointTo(?hctx2, ?heap2, ?hctxArray, ?arrayHeap, ?ctx, ?return) <-
   UpToReturnArrayIndexMayPointTo(?hctx2, ?heap2, ?hctxArray, ?arrayHeap, ?ctx, ?prevReturn),
   NextReturn[?prevReturn] = ?return,
   AllPredecessors:ArrayIndexMayPointTo
    (?hctx1, ?heap1, ?hctxArray, ?arrayHeap, ?ctx, ?return).

AllReturn:ArrayIndexMayPointTo(?hctx, ?heap, ?hctxArray, ?arrayHeap, ?ctx, ?method) <-
   UpToReturnArrayIndexMayPointTo(?hctx, ?heap, ?hctxArray, ?arrayHeap, ?ctx, ?return),
   !(NextReturn[?return] = _),
   Instruction:Method[?return] = ?method.
