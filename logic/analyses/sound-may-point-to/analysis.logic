#include "declarations.logic"

cons:MayContext:Initial[] = ctx, MayContext(ctx).
cons:HeapContext:Empty[] = hctx, MayHeapContext(hctx).


// The rules below create access paths from all variables
// and all access fields in the program.
cons:AccessPath:byVar[var] = ap, AccessPath(ap),
InitialComputedAccessPath(ap) <-
  Var:Type[var] = type,
  ReferenceType(type).

// Invariant: all computed access paths are type safe: the fields
// exist in the static type of the prefix. REVIEW: This may (rarely)
// prevent detection of valid aliasing.
cons:AccessPath:byField[fld, ap1] = ap2, AccessPath(ap2),
InitialComputedAccessPath(ap2) <-
  (LoadInstanceField:Base[insn] = base ;
   StoreInstanceField:Base[insn] = base),
  cons:AccessPath:byVar[base] = ap1,
  FieldInstruction:Signature[insn] = fld,
  Field:Type[fld] = type,
  ReferenceType(type).

cons:AccessPath:byStaticField[fld] = ap, AccessPath(ap),
InitialComputedAccessPath(ap) <-
  (LoadStaticField:To[insn] = _ ;
   StoreStaticField:From[insn] = _),
  FieldInstruction:Signature[insn] = fld,
  Field:Type[fld] =type,
  ReferenceType(type).

//component IntraproceduralMust {
//#include "IntraproceduralMust.logic"
//}


LibraryCollectionType(type) <-
  (root = "java.util.AbstractCollection" ;
   root = "java.util.AbstractMap"),
  SubtypeOf(type, root).

// TODO: Should these use LibraryCollectionType?
LibraryCollectionStoreOperation(invo) <-
  VirtualMethodInvocation:SimpleName[invo] = "add";
  VirtualMethodInvocation:SimpleName[invo] = "push";
  VirtualMethodInvocation:SimpleName[invo] = "set";
  VirtualMethodInvocation:SimpleName[invo] = "put".
LibraryCollectionLoadOperation(invo) <-
  VirtualMethodInvocation:SimpleName[invo] = "peek";
  VirtualMethodInvocation:SimpleName[invo] = "pop";
  VirtualMethodInvocation:SimpleName[invo] = "elementAt";
  VirtualMethodInvocation:SimpleName[invo] = "firstElement";
  VirtualMethodInvocation:SimpleName[invo] = "lastElement";
  VirtualMethodInvocation:SimpleName[invo] = "remove";
  VirtualMethodInvocation:SimpleName[invo] = "get". // TODO: better match in future

StoreCollection:From(insn, from) <-
  StoreArrayIndex:From[insn] = from.
StoreCollection:From(invo, from) <-
  LibraryCollectionStoreOperation(invo),
  (ActualParam[1, invo] = from;
   ActualParam[2, invo] = from).

StoreCollection:Base[insn] = base <-
  StoreArrayIndex:Base[insn] = base.
StoreCollection:Base[invo] = base <-
  LibraryCollectionStoreOperation(invo),
  VirtualMethodInvocation:Base[invo] = base.

LoadCollection:To[insn] = to <-
  LoadArrayIndex:To[insn] = to.
LoadCollection_To[invo] = to <-
  LibraryCollectionLoadOperation(invo),
  AssignReturnValue[invo] = to.

LoadCollection:Base[insn] = base <-
  LoadArrayIndex:Base[insn] = base.
LoadCollection:Base[invo] = base <-
  LibraryCollectionLoadOperation(invo),
  VirtualMethodInvocation:Base[invo] = base.

ThisVarOfConstructor[method] = this <-
   Method:SimpleName(method, "<init>"),
   ThisVar[method] = this.

// TODO what about the way it is computed in the must analysis (java)
// TODO what happens when it is a jump target
Method:FirstInstruction[method2] = insn <-
  Instruction:Index[insn] = 1,
  !IsJumpTarget(insn),
  Instruction:Method[insn] = method2.

StoreInstruction(insn) <-
  StoreStaticField:From[insn] = _ ;
  StoreInstanceField:From[insn] = _.

// TODO fix indexing
BBHeadIsFirstInstruction(firstInsn) <-
  BasicBlockBegin(firstInsn),
  Method:FirstInstruction[_] = firstInsn.

BasicBlockContainsCall(headInsn) <-
  BasicBlockHead[insn] = headInsn,
  MethodInvocation(insn),
  !IgnorableMethodInvocation(insn).

SomePathBetweenBasicBlocksContainsCall(prev, next) <-
  BasicBlockContainsCall(prev),
  MaySuccessorBBModuloThrow(next, prev).

SomePathFromFirstInstructionContainsCall(blockHead) <-
  BBHeadIsFirstInstruction(firstInsn),
  SomePathBetweenBasicBlocksContainsCall(firstInsn, blockHead).


/*
// Friendly API for access path display
AccessPath_ToString(ap, str) ->
   AccessPath(ap), string(str).

// loses lots of information, which may be confusing during debugging.
AccessPath_ToString(ap, str) <-
   AccessPath_ByVarInv(ap, v),
   _NameFromRefMode(v, str).
//   Var_Value(v,vs),
//   OptVar_DeclaringMethod(m,v),
//   MethodSignature_Value(m_ms),
//   str = vs + ms.

AccessPath_ToString(ap, str) <-
   AccessPath_ByStaticFieldInv(ap, f),
   _NameFromRefMode(f, str).

AccessPath_ToString(ap, str2) <-
   AccessPath_ByCollectionVarInv(ap, v),
   _NameFromRefMode(v, str),
   str2 = "collection on " + str.

AccessPath_ToString(ap, str) <-
   AccessPath_Base(ap, base),
   AccessPath_LastField(ap, fld),
   AccessPath_ToString(base, strBase),
   _NameFromRefMode(fld, fldName),
   baseDot = strBase + ".",
   str = baseDot + fldName.

_NameFromRefMode(ref, name) ->
   string(ref), string(name).

_NameFromRefMode(ref, varName) <-
   Var_Value(_:ref),
   _VarRefModeLastTokenIndex(ref, maxIdx),
   string_split[ref, "/", maxIdx] = varName.
lang:derivationType[`_NameFromRefMode] = "Derived".

_NameFromRefMode(ref, varName) <-
   FieldSignature_Value(_:ref),
   _FieldRefModeLastTokenIndex(ref, maxIdx),
   string_split[ref, "/", maxIdx] = varName.
lang:derivationType[`_NameFromRefMode] = "Derived".

_VarRefModeLastTokenIndex(ref, maxIdx) <-
   agg<<maxIdx = max(idx)>>
   Var_Value(_:ref),
   string_split[ref, "/", idx] = _.

_FieldRefModeLastTokenIndex(ref, maxIdx) <-
   agg<<maxIdx = max(idx)>>
   FieldSignature_Value(_:ref),
   string_split[ref, "/", idx] = _.
*/


/*
  ///// POINT1--unchanged access paths code

  //// Dealing with unchanged access paths (below) hasn't proven
  //// worthwhile. It's not surprising. The callee has no name for
  //// this access path. The only hope is that it will survive through
  //// virtual calls and will come back to the caller (whereas the
  //// conservative must-pre-analysis won't consider virtual calls it
  //// cannot resolve in its naive way).

  // This is quite expensive if not restricted. Currently used only for
  // non-resolved virtual calls. For resolved ones, we have a frame rule
  // to propagate the information right over the method call in many
  // cases (and we ignore the rest for now).
  // ChangedBaseAtInvocation(var, invo) <-
  //   ActualParam(_, invo, var);
  //   VirtualMethodInvocation_Base(invo, var);
  //   SpecialMethodInvocation_Base(invo, var).

  // OptPotentialAccessPathMayPointToPropagation(hctx, heap, invo, calleeCtx, toMethod, ap) <-
  //   MayCallGraphEdge_ToMethod(toMethod, callerCtx, invo),
  //   !May_MustCallGraphEdge_ToMethod(callerCtx, invo, toMethod),
  //   MayCallGraphEdge_Context(callerCtx, invo, calleeCtx),
  //   Before_AccessPathMayPointTo(hctx, heap, ap, callerCtx, invo).

  // Before_AccessPathMayPointTo(hctx, heap, ap, calleeCtx, firstInsn) <_
  //    OptPotentialAccessPathMayPointToPropagation(hctx, heap, invo, calleeCtx, toMethod, ap),
  //    AccessPath_BaseVar(ap, baseVar),
  //    !ChangedBaseAtInvocation(baseVar, invo),
  //    SingleFieldAccessPath(fld, ap),
  //    (MethodMayAssignField(fld, toMethod);
  //     MethodHasUnresolvedInvocation(toMethod)),
  //    FirstInstructionOfMethod(toMethod, firstInsn).

  // Before_AccessPathMayPointTo(hctx, heap, ap, calleeCtx, firstInsn) <-
  //    OptPotentialAccessPathMayPointToPropagation(hctx, heap, invo, calleeCtx, toMethod, ap),
  //    AccessPath_BaseVar(ap, baseVar),
  //    !ChangedBaseAtInvocation(baseVar, invo),
  //    _DoubleFieldAccessPath(fld1, fld2, ap),
  //    (MethodMayAssignField(fld1, toMethod);
  //     MethodMayAssignField(fld2, toMethod);
  //     MethodHasUnresolvedInvocation(toMethod)),
  //    FirstInstructionOfMethod(toMethod, firstInsn).
*/


//// Enter at POINT2---IgnorableMethodInvocation
//// ====================================
//// BEGIN configuration of ignorable method calls

// Some calls to native or otherwise complex methods need to be
// modeled, i.e., ignored. E.g., fillInStackTrace is a native method
// called in the constructor of a (ubiquitous) java.lang.Throwable. If
// not ignored, no image of the heap propagates anywhere.
// TODO: do a better match (on full sig) than just on SimpleName.

/*
IgnorableForNonCollectionsMethodInvocation(invo) -> MethodInvocation(invo).
IgnorableForStaticsMethodInvocation(invo) -> MethodInvocation(invo).

IgnorableMethodInvocation(invo) <-
   VirtualMethodInvocation_SimpleName(invo, "fillInStackTrace"); // Throwable
   VirtualMethodInvocation_SimpleName(invo, "equals");  // Object
   VirtualMethodInvocation_SimpleName(invo, "hashCode");
   VirtualMethodInvocation_SimpleName(invo, "toString");
   VirtualMethodInvocation_SimpleName(invo, "println"); // PrintStream
   StaticMethodInvocation_SimpleName(invo, "parseInt"); // Integer
   VirtualMethodInvocation_SimpleName(invo, "endsWith"); // String
   StaticMethodInvocation_SimpleName(invo, "floatToRawIntBits"); // Float
   // these are used in the HashMap "put" method!
   StaticMethodInvocation_SimpleName(invo, "intBitsToFloat");
   // From this point on, it's just a test to see if these natives matter.
   StaticMethodInvocation_SimpleName(invo, "encoding"); // Console
   StaticMethodInvocation_SimpleName(invo, "echo");
   StaticMethodInvocation_SimpleName(invo, "istty");
   VirtualMethodInvocation_SimpleName(invo, "sync"); // FileDescriptor
   StaticMethodInvocation_SimpleName(invo, "initIDs");
   VirtualMethodInvocation_SimpleName(invo, "open"); // FileInputStream
   VirtualMethodInvocation_SimpleName(invo, "read0");
   VirtualMethodInvocation_SimpleName(invo, "readBytes");
   VirtualMethodInvocation_SimpleName(invo, "skip");
   VirtualMethodInvocation_SimpleName(invo, "available");
   VirtualMethodInvocation_SimpleName(invo, "close0");
   VirtualMethodInvocation_SimpleName(invo, "write"); // FileOutputStream
   VirtualMethodInvocation_SimpleName(invo, "writeBytes");
   VirtualMethodInvocation_SimpleName(invo, "availableProcessors"); // Runtime
   VirtualMethodInvocation_SimpleName(invo, "freeMemory");
   VirtualMethodInvocation_SimpleName(invo, "totalMemory");
   VirtualMethodInvocation_SimpleName(invo, "maxMemory");
   VirtualMethodInvocation_SimpleName(invo, "gc");
   StaticMethodInvocation_SimpleName(invo, "runFinalization0");
   StaticMethodInvocation_SimpleName(invo, "sin"); // StrictMath
   StaticMethodInvocation_SimpleName(invo, "cos");
   StaticMethodInvocation_SimpleName(invo, "tan");
   StaticMethodInvocation_SimpleName(invo, "log");
   StaticMethodInvocation_SimpleName(invo, "pow");
   StaticMethodInvocation_SimpleName(invo, "currentThread"); // Thread
   StaticMethodInvocation_SimpleName(invo, "yield");
   StaticMethodInvocation_SimpleName(invo, "sleep");
   VirtualMethodInvocation_SimpleName(invo, "start0");
   VirtualMethodInvocation_SimpleName(invo, "isInterrupted");
   VirtualMethodInvocation_SimpleName(invo, "isAlive");
   StaticMethodInvocation_SimpleName(invo, "holdsLock");
   StaticMethodInvocation_SimpleName(invo, "getThreads");
   StaticMethodInvocation_SimpleName(invo, "dumpThreads");
   VirtualMethodInvocation_SimpleName(invo, "setPriority");
   VirtualMethodInvocation_SimpleName(invo, "stop0");
   VirtualMethodInvocation_SimpleName(invo, "suspend0");
   VirtualMethodInvocation_SimpleName(invo, "resume0");
   VirtualMethodInvocation_SimpleName(invo, "interrupt0");
   VirtualMethodInvocation_SimpleName(invo, "isAlive");
   VirtualMethodInvocation_SimpleName(invo, "getStackTraceDepth"); // Throwable
   VirtualMethodInvocation_SimpleName(invo, "getStackTraceElement");
   VirtualMethodInvocation_SimpleName(invo, "forkAndExec");  // UnixProcess
   VirtualMethodInvocation_SimpleName(invo, "wait"); // Object
   VirtualMethodInvocation_SimpleName(invo, "notify");
   VirtualMethodInvocation_SimpleName(invo, "notifyAll").

IgnorableForStaticsMethodInvocation(invo) <-
   VirtualMethodInvocation_SimpleName(invo, "intern"); // String
   VirtualMethodInvocation_SimpleName(invo, "clone"); // Object
   VirtualMethodInvocation_SimpleName(invo, "append"). // StringBuilder

// Collections
IgnorableForNonCollectionsMethodInvocation(invo) <-
  LibraryCollectionStoreOperation(invo);
  LibraryCollectionLoadOperation(invo).

StaticMethodInvocation_SimpleName(invo, simplename) -> MethodInvocation(invo), string(simplename).
StaticMethodInvocation_SimpleName(invo, simplename) <-
   MethodInvocation_Signature(invo, signature),
   StaticMethodInvocation_Insn(invo),
   MethodSignature_SimpleName(signature, simplename).
*/

//// END configuration of ignorable method calls


/*
//// POINT4 code
// //// Commented out for now. Does not make that much difference.
// //// InstanceFieldMayPointTo inferences rarely get stopped because of
// //// library calls.
// //// ------------------------------
// // Logic for assuming the library does not affect application fields,
// // except via reflection.
// ApplicationField(fld) <-
//    FieldSignature_DeclaringClass(fld, class),
//    ApplicationClass(class).

// ApplicationMethod(meth) <-
//    MethodSignature_DeclaringType(meth, declaringType),
//    ApplicationClass(declaringType).

// MethodCallsReflection(meth) <-
//    Instruction_Method(invo, meth),
//    MethodInvocation_Signature(invo, sig),
//    string_substring(sig, 0, _, "<java.lang.reflect").

// _Opt2MethodInvocation_Signature(invo, inMeth, toMeth) <-
//    (StaticMethodInvocation_Insn(invo);
//     SpecialMethodInvocation_Insn(invo)),
//    MethodInvocation_Signature(invo, toMeth),
//    Instruction_Method(invo, inMeth).

// // exact resolution for static/special
// MethodCallsReflection(inMeth) <-
//    _Opt2MethodInvocation_Signature(_, inMeth, toMeth),
//    MethodCallsReflection(toMeth).

// // underapproximation of virtual method resolution, as if static
// _Opt2MethodInvocation_Signature(invo, inMeth, toMeth) <-
//    VirtualMethodInvocation_Insn(invo),
//    MethodInvocation_Signature(invo, toMeth),
//    Instruction_Method(invo, inMeth).

// // Naive virtual method resolution, based on name. REVIEW: too conservative
// _OptVirtualMethodInvocation_Simplename(inMeth, simpleName) <-
//    VirtualMethodInvocation_SimpleName(invo, simpleName),
//    Instruction_Method(invo, inMeth).

// MethodCallsReflection(inMeth) <-
//    MethodCallsReflection(toMeth),
//    MethodSignature_SimpleName(toMeth, toMethSimpleName),
//    _OptVirtualMethodInvocation_Simplename(inMeth, toMethSimpleName).

// InstanceFieldMayPointTo(hctx, heap, fld, hctxBase, baseHeap, ctx, insn) <-
//    AllPredecessors_InstanceFieldMayPointTo(hctx, heap, fld, hctxBase, baseHeap, ctx, insn),
//    MethodInvocation_Signature(insn, calledMethod), // underapproximate
// //   string_substring[calledMethod, 0, string_length[str]] != str, str = "<java.lang.reflect",
//    !MethodCallsReflection(calledMethod),
//    ApplicationField(fld),
//    !ApplicationMethod(calledMethod).

// StaticFieldMayPointTo(hctx, heap, fld, ctx, insn) <-
//    AllPredecessors_StaticFieldMayPointTo(hctx, heap, fld, ctx, insn),
//    MethodInvocation_Signature(insn, calledMethod),
// //   string_substring[calledMethod, 0, string_length[str]] != str, str = "<java.lang.reflect",
//    !MethodCallsReflection(calledMethod),
//    ApplicationField(fld),
//    !ApplicationMethod(calledMethod).

// // TODO: also extend to collections
*/


/*
//// POINT5: DominatedPathMayInvalidateFieldPointsTo
// // TODO: currently has no impact. Comment out and re-check when non-invalidating
// //       method calls are added

// // Interesting addition to frame rules:
// // propagate in case of non-invalidating dominated predecessors.

// // The path (dominated by dominator) that ends at insn
// // may invalidate some field.
// DominatedPathMayInvalidateFieldPointsTo(fld, insn, dominator) <-
//    Dominates(dominator, insn),
//    BasicBlockMayInvalidateFieldPointsTo(fld, insn).

// DominatedPathMayInvalidateFieldPointsTo(fld, insn, dominator) <-
//    DominatedPathMayInvalidateFieldPointsTo(fld, otherInsn, dominator),
//    MaySuccessorBBModuloThrow(insn, otherInsn),
//    Dominates(dominator, insn).

// ExistsFieldInvalidatingPathToPredecessor(fld, prevHead, dominator) <-
//    DominatesItsPredecessorInstruction(prevInsn, dominator),
//    BasicBlockHead(prevInsn, prevHead),
//    DominatedPathMayInvalidateFieldPointsTo(fld, prevHead, dominator).

// ExistsFieldInvalidatingPathToSomePredecessor(fld, dominator) <-
//    ExistsFieldInvalidatingPathToPredecessor(fld, _, dominator).

// BasicBlockMayInvalidateAllFieldsPointsTo(headInsn) <-
//    BasicBlockHead(insn, headInsn),
//    !IndifferentInstruction(insn),
//    !FieldInstruction(insn).

// // The path (dominated by dominator) that ends at insn
// // may invalidate any field.
// DominatedPathMayInvalidateAllFieldsPointsTo(insn, dominator) <-
//    Dominates(dominator, insn),
//    BasicBlockMayInvalidateAllFieldsPointsTo(insn).

// DominatedPathMayInvalidateAllFieldsPointsTo(insn, dominator) <-
//    DominatedPathMayInvalidateAllFieldsPointsTo(otherInsn, dominator),
//    MaySuccessorBBModuloThrow(insn, otherInsn),
//    Dominates(dominator, insn).

// ExistsAllFieldsInvalidatingPathToPredecessor(prevHead, dominator) <-
//    DominatesItsPredecessorInstruction(prevInsn, dominator),
//    BasicBlockHead(prevInsn, prevHead),
//    DominatedPathMayInvalidateAllFieldsPointsTo(prevHead, dominator).

// ExistsAllFieldsInvalidatingPathToSomePredecessor(dominator) <-
//    ExistsAllFieldsInvalidatingPathToPredecessor(_, dominator).

// InstanceFieldMayPointTo(hctx, heap, fld, hctxBase, baseHeap, ctx, insn) <-
//    AllNonDomPredecessors_InstanceFieldMayPointTo(hctx, heap, fld, hctxBase, baseHeap, ctx, insn),
//    !ExistsFieldInvalidatingPathToSomePredecessor(fld, insn),
//    !ExistsAllFieldsInvalidatingPathToSomePredecessor(insn),
//    DominatesItsPredecessorInstruction(_, insn).

// StaticFieldMayPointTo(hctx, heap, fld, ctx, insn) <-
//    AllNonDomPredecessors_StaticFieldMayPointTo(hctx, heap, fld, ctx, insn),
//    !ExistsFieldInvalidatingPathToSomePredecessor(fld, insn),
//    !ExistsAllFieldsInvalidatingPathToSomePredecessor(insn),
//    DominatesItsPredecessorInstruction(_, insn).

// // TODO: update with collections
*/
