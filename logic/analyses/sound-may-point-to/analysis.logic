// A sound may-point-to analysis ("shall"-point-to?
// "True-may"-point-to?). Does not conclude anything if it is not
// certain it over-approximates all possible points-to targets. That
// is, an empty points-to set means "anything can be pointed to".

// Ignore verification of calculation in head
lang:compiler:warning:SPECIFIC_STARRED_EDGE_IN_SAFETY_GRAPH_CYCLE[] = false.

//// =====================================
//// The main concepts:

// May-point-to information in a specific context (which may be an
// all-contexts value).

// Whenever (if) it is reached under context ?ctx, variable ?var may point to an object
// allocated at site ?heap. Since we assume SSA and variables are ensured initialized before use,
// there is no point in keeping this information per-instruction.
MayPointTo(?hctx, ?heap, ?ctx, ?var) ->
   MayHeapContext(?hctx), HeapAllocation(?heap),
   Var(?var), MayContext(?ctx).

InstanceFieldMayPointTo(?hctx, ?heap, ?field, ?hctxBase, ?baseHeap, ?ctx, ?insn) ->
   MayHeapContext(?hctx), HeapAllocation(?heap),
   FieldSignature(?field), MayHeapContext(?hctxBase),
   HeapAllocation(?baseHeap), MayContext(?ctx), Instruction(?insn).

StaticFieldMayPointTo(?hctx, ?heap, ?field, ?ctx, ?insn) ->
   MayHeapContext(?hctx), HeapAllocation(?heap),
   FieldSignature(?field), MayContext(?ctx), Instruction(?insn).

CollectionMayPointTo(?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?insn) ->
   MayHeapContext(?hctx), HeapAllocation(?heap),
   MayHeapContext(?hctxColl), HeapAllocation(?collHeap),
   MayContext(?ctx), Instruction(?insn).

RootMethodForMayAnalysis(?meth) -> MethodSignature(?meth).

// Auxiliary, simple must-point-to analysis, to avoid monotonicity
// problems with "forall MayPointTo". Currently not base on the whole
// must-point-to code base, since the latter is not guaranteed sound.
_MustPointTo:Object[?ctx, ?var] = ?heap ->
   HeapAllocation(?heap), Var(?var), MayContext(?ctx).
_MustPointTo:Hctx[?ctx, ?var] = ?hctx ->
   MayHeapContext(?hctx), Var(?var), MayContext(?ctx).

// Just for baseline comparisons. Should be very cheap to compute.
IntraproceduralMustPointTo:Object[?ctx, ?var] = ?heap ->
   HeapAllocation(?heap), Var(?var), MayContext(?ctx).
IntraproceduralMustPointTo:Hctx[?ctx, ?var] = ?hctx ->
   MayHeapContext(?hctx), Var(?var), MayContext(?ctx).


//// =====================================
//// BEGIN MayPointTo code

// Need to identify relevant (i.e., reachable) methods for the
// analysis, instead of blindly applying it to all available code.
ReachableMethodUnderMayContext(?ctx, ?meth) ->
   MayContext(?ctx), MethodSignature(?meth).

ReachableMethodUnderMayContext(?ctx, ?meth) <-
   RootMethodForMayAnalysis(?meth),
   InitialMayContext[] = ?ctx.

ReachableMethodUnderMayContext(?ctx, ?meth) <-
   MayCallGraphEdge:Context[?callerCtx, ?invo] = ?ctx,
   MayCallGraphEdge:ToMethod(?meth, ?callerCtx, ?invo).

ReachableMayContext(?ctx) <-
   ReachableMethodUnderMayContext(?ctx, _).
   
// Root of all inferences. Assigning new heap allocations.
// REVIEW: This introduces dependency on string-constants.logic
//RecordMacroMay(?ctx, ?heap, ?hctx),
MayHeapContext(?hctx), EmptyHeapContext[] = ?hctx,
IntraproceduralMustPointTo:Object[?ctx, ?var] = ?heap,
IntraproceduralMustPointTo:Hctx[?ctx, ?var] = ?hctx,
_MustPointTo:Object[?ctx, ?var] = ?heap,
_MustPointTo:Hctx[?ctx, ?var] = ?hctx,
MayPointTo(?hctx, ?heap, ?ctx, ?var) <-
   AssignNormalHeapAllocation(?heap, ?var, ?inMeth),
   ReachableMethodUnderMayContext(?ctx, ?inMeth).

// strings and others
IntraproceduralMustPointTo:Object[?ctx, ?var] = ?heap,
IntraproceduralMustPointTo:Hctx[?ctx, ?var] = ?hctx,
_MustPointTo:Object[?ctx, ?var] = ?heap,
_MustPointTo:Hctx[?ctx, ?var] = ?hctx,
MayPointTo(?hctx, ?heap, ?ctx, ?var) <-
   AssignContextInsensitiveHeapAllocation(?heap, ?var, ?inMeth),
   ?hctx = EmptyHeapContext[],
   ReachableMethodUnderMayContext(?ctx, ?inMeth).


// null assignments
_OptInstruction:Method(?insn, ?inMeth) <-
   Instruction:Method[?insn] = ?inMeth.
   
MayHeapContext(?hctx), EmptyHeapContext[] = ?hctx,
IntraproceduralMustPointTo:Object[?ctx, ?var] = ?heap,
IntraproceduralMustPointTo:Hctx[?ctx, ?var] = ?hctx,
_MustPointTo:Object[?ctx, ?var] = ?heap,
_MustPointTo:Hctx[?ctx, ?var] = ?hctx,
MayPointTo(?hctx, ?heap, ?ctx, ?var) <-
   AssignNull:Insn(?insn),
   AssignInstruction:To[?insn] = ?var,
   HeapAllocation:Null[] = ?heap,
   _OptInstruction:Method(?insn, ?inMeth),
   ReachableMethodUnderMayContext(?ctx, ?inMeth).

// Move, but not Phi nodes, which are also represented as local assignments.
MayPointTo(?hctx, ?heap, ?ctx, ?to) <-
   AssignLocal:Insn(?insn),
   !(PhiNodeHead[?insn] = _),
   AssignInstruction:To[?insn] = ?to,
   AssignLocal:From[?insn] = ?from,
   MayPointTo(?hctx, ?heap, ?ctx, ?from).

_MustPointTo:Object[?ctx, ?to] = ?heap,
_MustPointTo:Hctx[?ctx, ?to] = ?hctx <-
   AssignLocal:Insn(?insn),
   !(PhiNodeHead[?insn] = _),
   AssignInstruction:To[?insn] = ?to,
   AssignLocal:From[?insn] = ?from,
   _MustPointTo:Object[?ctx, ?from] = ?heap,
   _MustPointTo:Hctx[?ctx, ?from] = ?hctx.

// sadly, duplicate of above
IntraproceduralMustPointTo:Object[?ctx, ?to] = ?heap,
IntraproceduralMustPointTo:Hctx[?ctx, ?to] = ?hctx <-
   AssignLocal:Insn(?insn),
   !(PhiNodeHead[?insn] = _),
   AssignInstruction:To[?insn] = ?to,
   AssignLocal:From[?insn] = ?from,
   IntraproceduralMustPointTo:Object[?ctx, ?from] = ?heap,
   IntraproceduralMustPointTo:Hctx[?ctx, ?from] = ?hctx.

// casts are like local assignments
//// TODO: filter our badly typed values
MayPointTo(?hctx, ?heap, ?ctx, ?to) <-
   AssignCast:Insn(?insn),
   AssignInstruction:To[?insn] = ?to,
   AssignCast:From[?insn] = ?from,
   MayPointTo(?hctx, ?heap, ?ctx, ?from).

_MustPointTo:Object[?ctx, ?to] = ?heap,
_MustPointTo:Hctx[?ctx, ?to] = ?hctx <-
   AssignCast:Insn(?insn),
   AssignInstruction:To[?insn] = ?to,
   AssignCast:From[?insn] = ?from,
   _MustPointTo:Object[?ctx, ?from] = ?heap,
   _MustPointTo:Hctx[?ctx, ?from] = ?hctx.

// sadly, duplicate of above
IntraproceduralMustPointTo:Object[?ctx, ?to] = ?heap,
IntraproceduralMustPointTo:Hctx[?ctx, ?to] = ?hctx <-
   AssignCast:Insn(?insn),
   AssignInstruction:To[?insn] = ?to,
   AssignCast:From[?insn] = ?from,
   IntraproceduralMustPointTo:Object[?ctx, ?from] = ?heap,
   IntraproceduralMustPointTo:Hctx[?ctx, ?from] = ?hctx.

// Phi
MayPointTo(?hctx, ?heap, ?ctx, ?var) <-
   MayPointToUpToPhiInstruction(?hctx, ?heap, ?ctx, ?lastInsn),
   !(NextInSamePhiNode[?lastInsn] = _),
   AssignInstruction:To[?lastInsn] = ?var.

_MustPointTo:Object[?ctx, ?var] = ?heap,
_MustPointTo:Hctx[?ctx, ?var] = ?hctx <-
   _MustPointToUpToPhiInstruction:Object[?ctx, ?lastInsn] = ?heap,
   _MustPointToUpToPhiInstruction:Hctx[?ctx, ?lastInsn] = ?hctx,
   !(NextInSamePhiNode[?lastInsn] = _),
   AssignInstruction:To[?lastInsn] = ?var.

// sadly, duplicate of above
IntraproceduralMustPointTo:Object[?ctx, ?var] = ?heap,
IntraproceduralMustPointTo:Hctx[?ctx, ?var] = ?hctx <-
   IntraproceduralMustPointToUpToPhiInstruction:Object[?ctx, ?lastInsn] = ?heap,
   IntraproceduralMustPointToUpToPhiInstruction:Hctx[?ctx, ?lastInsn] = ?hctx,
   !(NextInSamePhiNode[?lastInsn] = _),
   AssignInstruction:To[?lastInsn] = ?var.

// static or special method invocation
_OptMethodInvocation:Signature(?toMeth, ?invo, ?inMeth) <-
   (StaticMethodInvocation:Insn(?invo);
    SpecialMethodInvocation:Insn(?invo)), 
   MethodInvocation:Signature[?invo] = ?toMeth,
   Instruction:Method[?invo] = ?inMeth.

//MergeMacroMay(?ctx, ?invo, ?hctx, ?heap, ?calleeCtx),
PushMayContext[?invo,?ctx] = ?calleeCtx, MayContext(?calleeCtx),
MayCallGraphEdge:ToMethod(?toMeth, ?ctx, ?invo),
MayCallGraphEdge:Context[?ctx, ?invo] = ?calleeCtx <-
   _OptMethodInvocation:Signature(?toMeth, ?invo, ?inMeth),
   ReachableMethodUnderMayContext(?ctx, ?inMeth),
   MayContextDepth[?ctx] < MaxMayContextDepth[].

// special method invocation "this" variable assignment
_OptSpecialMethodInvocation:Base(?invo, ?base) <-
   SpecialMethodInvocation:Base[?invo] = ?base.

_OptPotentialSpecialMethodBase(?hctx, ?heap, ?ctx, ?invo) <-
   _OptSpecialMethodInvocation:Base(?invo, ?base),
   MayPointTo(?hctx, ?heap, ?ctx, ?base).

MayPointTo(?hctx, ?heap, ?calleeCtx, ?this) <-
   _OptPotentialSpecialMethodBase(?hctx, ?heap, ?ctx, ?invo),
   MayCallGraphEdge:ToMethod(?toMeth, ?ctx, ?invo),
   MayCallGraphEdge:Context[?ctx, ?invo] = ?calleeCtx,
   ThisVar[?toMeth] = ?this.

_OptVirtualMethodInvocation:Base(?invo, ?base) <-
   VirtualMethodInvocation:Base[?invo] = ?base.

_OptPotentialVirtualMethodBase(?hctx, ?heap, ?ctx, ?invo) <-
   _OptVirtualMethodInvocation:Base(?invo, ?base),
   MayPointTo(?hctx, ?heap, ?ctx, ?base).

// virtual method invocation
//MergeMacroMay(?ctx, ?invo, ?hctx, ?heap, ?calleeCtx),
PushMayContext[?invo,?ctx] = ?calleeCtx, MayContext(?calleeCtx),
MayCallGraphEdge:ToMethod(?toMeth, ?ctx, ?invo),
MayCallGraphEdge:Context[?ctx, ?invo] = ?calleeCtx,
MayPointTo(?hctx, ?heap, ?calleeCtx, ?this) <-
   _OptPotentialVirtualMethodBase(?hctx, ?heap, ?ctx, ?invo),
   HeapAllocation:Type[?heap] = ?heaptype,
   VirtualMethodInvocation:SimpleName[?invo] = ?simplename,
   VirtualMethodInvocation:Descriptor[?invo] = ?descriptor,
   MethodLookup[?simplename, ?descriptor, ?heaptype] = ?toMeth,
   ThisVar[?toMeth] = ?this,
   MayContextDepth[?ctx] < MaxMayContextDepth[].

// propagate "this" for _MustPointTo, establish must-call-graph, when
// applicable
_OptCertainMethodBase(?hctx, ?heap, ?ctx, ?invo) <-
   (_OptSpecialMethodInvocation:Base(?invo, ?base);
    _OptVirtualMethodInvocation:Base(?invo, ?base)),
   _MustPointTo:Object[?ctx, ?base] = ?heap,
   _MustPointTo:Hctx[?ctx, ?base] = ?hctx.

_MustCallGraphEdge:ToMethod[?ctx, ?invo] = ?toMeth,
_MustCallGraphEdge:Context[?ctx, ?invo] = ?calleeCtx,
_MustPointTo:Object[?calleeCtx, ?this] = ?heap,
_MustPointTo:Hctx[?calleeCtx, ?this] = ?hctx <-
   _OptCertainMethodBase(?hctx, ?heap, ?ctx, ?invo),
   MayCallGraphEdge:ToMethod(?toMeth, ?ctx, ?invo),
   MayCallGraphEdge:Context[?ctx, ?invo] = ?calleeCtx,
   ThisVar[?toMeth] = ?this.

// again, just for baseline stats
IntraproceduralCertainMethodBase(?hctx, ?heap, ?ctx, ?invo) <-
   (_OptSpecialMethodInvocation:Base(?invo, ?base);
    _OptVirtualMethodInvocation:Base(?invo, ?base)),
   IntraproceduralMustPointTo:Object[?ctx, ?base] = ?heap,
   IntraproceduralMustPointTo:Hctx[?ctx, ?base] = ?hctx.


/*
// Uses UNSOUND may-point-to, just for comparison during testing.
//// Has already stopped being useful, since it doesn't bind "this".
//// It even yields lower numbers than the sound rule.
PushMayContext[?invo,?ctx] = ?calleeCtx, MayContext(?calleeCtx),
MayCallGraphEdge:ToMethod(?toMeth, ?ctx, ?invo),
MayCallGraphEdge:Context[?ctx, ?invo] = ?calleeCtx <-
   VirtualMethodInvocation:Base[?invo] = ?heap,
   TypeResolvedVar(?heap),
   VPTTypeForVarModNull(?heaptype, ?heap),
   VirtualMethodInvocation:SimpleName[?invo] = ?simplename,
   VirtualMethodInvocation:Descriptor[?invo] = ?descriptor,
   MethodLookup[?simplename, ?descriptor, ?heaptype] = ?toMeth,
   Instruction:Method[?invo] = ?inMeth,
   ReachableMethodUnderMayContext(?ctx, ?inMeth),
   MayContextDepth[?ctx] < MaxMayContextDepth[].
*/

// args
InvocationActualFormalAssignment(?calleeCtx, ?formal, ?callerCtx, ?actual) <-
   MayCallGraphEdge:ToMethod(?toMethod, ?callerCtx, ?invo),
   MayCallGraphEdge:Context[?callerCtx, ?invo] = ?calleeCtx,
   FormalParam[?index, ?toMethod] = ?formal,
   ActualParam[?index, ?invo] = ?actual.

MayPointTo(?hctx, ?heap, ?calleeCtx, ?formal) <-
   InvocationActualFormalAssignment(?calleeCtx, ?formal, ?callerCtx, ?actual),
   MayPointTo(?hctx, ?heap, ?callerCtx, ?actual).

_MustPointTo:Object[?calleeCtx, ?formal] = ?heap,
_MustPointTo:Hctx[?calleeCtx, ?formal] = ?hctx <-
   InvocationActualFormalAssignment(?calleeCtx, ?formal, ?callerCtx, ?actual),
   _MustPointTo:Object[?callerCtx, ?actual] = ?heap,
   _MustPointTo:Hctx[?callerCtx, ?actual] = ?hctx.

ReturnValueOfCallAssignedTo(?callerCtx, ?to, ?calleeCtx, ?toMethod) <-
   MayCallGraphEdge:ToMethod(?toMethod, ?callerCtx, ?invo),
   MayCallGraphEdge:Context[?callerCtx, ?invo] = ?calleeCtx,
   AssignReturnValue[?invo] = ?to.

// return vals
MayPointTo(?hctx, ?heap, ?callerCtx, ?to) <-
   ReturnValueOfCallAssignedTo(?callerCtx, ?to, ?calleeCtx, ?toMethod),
   AllReturn:MayPointTo(?hctx, ?heap, ?calleeCtx, ?toMethod).

// for must-point-to, we need a resolved call, otherwise multiple values
// will flow back.
ReturnValueOfResolvedCallAssignedTo(?callerCtx, ?to, ?calleeCtx, ?toMethod) <-
   _MustCallGraphEdge:ToMethod[?callerCtx, ?invo] = ?toMethod,
   _MustCallGraphEdge:Context[?callerCtx, ?invo] = ?calleeCtx,
   AssignReturnValue[?invo] = ?to.

_MustPointTo:Object[?callerCtx, ?to] = ?heap,
_MustPointTo:Hctx[?callerCtx, ?to] = ?hctx <-
   ReturnValueOfResolvedCallAssignedTo(?callerCtx, ?to, ?calleeCtx, ?toMethod),
   _AllReturn:MustPointTo:Object[?calleeCtx, ?toMethod] = ?heap,
   _AllReturn:MustPointTo:Hctx[?calleeCtx, ?toMethod] = ?hctx.


FirstInstructionOfMethod[?meth] = ?firstInsn <-
   OptInstructionFromMethodIndex[?meth, 1] = ?firstInsn,
   !IsJumpTarget(?firstInsn).

_OptFieldFromClass(?fld, ?class) <-
   FieldSignature:DeclaringClass[?fld] = ?class.

_OptThisVarOfConstructor(?method, ?this) <-
   MethodSignature:SimpleName[?method] = "<init>",
   ThisVar[?method] = ?this.

// Handle constructors and initialization to null. This is key:
// it initializes InstanceFieldMayPointTo inferences. Without these
// rules, there would be zero facts. All other rules require a prior
// InstanceFieldMayPointTo.
MayHeapContext(?hctx), EmptyHeapContext[] = ?hctx,
AllPredecessors:InstanceFieldMayPointTo
 (?hctx, ?nullHeap, ?fld, ?hctxBase, ?baseHeap, ?calleeCtx, ?firstInsn) <-
   _OptThisVarOfConstructor(?ctorMethod, ?this),
   FirstInstructionOfMethod[?ctorMethod] = ?firstInsn,
   MayPointTo(?hctxBase, ?baseHeap, ?calleeCtx, ?this),
   HeapAllocation:Type[?baseHeap] = ?heapType,
   _OptFieldFromClass(?fld, ?heapType),
   !FieldModifier(Modifier:static[], ?fld),
   FieldSignature:Type[?fld] = ?fldType,
   ReferenceType(?fldType),
   HeapAllocation:Null[] = ?nullHeap.

// initialize arrays and library collections to null at allocation
Temp4(?hctx, ?nullHeap, ?hctxArray, ?arrayHeap, ?ctx, ?insn),
MayHeapContext(?hctx), EmptyHeapContext[] = ?hctx,
CollectionMayPointTo(?hctx, ?nullHeap, ?hctxArray, ?arrayHeap, ?ctx, ?insn) <-
   AssignHeapAllocation:Heap[?insn] = ?arrayHeap,
   HeapAllocation:Type[?arrayHeap] = ?type,
   (ArrayType(?type); LibraryCollectionType(?type)),
   Instruction:Method[?insn] = ?inMeth,
   ReachableMethodUnderMayContext(?ctx, ?inMeth),
   HeapAllocation:Null[] = ?nullHeap,
   EmptyHeapContext[] = ?hctxArray.

LibraryCollectionRoot(?type) <-
   Type(?type),
   (Type:fqn(?type:"java.util.AbstractCollection");
    Type:fqn(?type:"java.util.AbstractMap")).   
LibraryCollectionType(?type) <-
   Superclass(?type, ?collRoot),
   LibraryCollectionRoot(?collRoot).

/*
//// This is just a very expensive no-op. clinit methods never get called
//// directly, so whatever inferences we make never propagate elsewhere.
FirstInstructionOfReachableInitializer(?firstInsn, ?ctx, ?initMethod) <-
   ReachableMethodUnderMayContext(?ctx, ?initMethod),
   MethodSignature:SimpleName[?initMethod] = "<clinit>",
   FirstInstructionOfMethod[?initMethod] = ?firstInsn.

// Same for class initializers
MayHeapContext(?hctx), EmptyHeapContext[] = ?hctx,
AllPredecessors:StaticFieldMayPointTo(?hctx, ?nullHeap, ?fld, ?calleeCtx, ?firstInsn) <-
   FirstInstructionOfReachableInitializer(?firstInsn, ?calleeCtx, ?initMethod),
   MethodSignature:DeclaringType[?initMethod] = ?type,
   _OptFieldFromClass(?fld, ?type),
   FieldModifier(Modifier:static[], ?fld),
   FieldSignature:Type[?fld] = ?fldType,
   ReferenceType(?fldType),
   HeapAllocation:Null[] = ?nullHeap.
*/

// propagate (instance/static) field must-point-to info
AllPredecessors:InstanceFieldMayPointTo
 (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?calleeCtx, ?firstInsn) <-
   MayCallGraphEdge:ToMethod(?toMethod, ?callerCtx, ?invo),
   MayCallGraphEdge:Context[?callerCtx, ?invo] = ?calleeCtx,
   FirstInstructionOfMethod[?toMethod] = ?firstInsn,
   AllPredecessors:InstanceFieldMayPointTo
    (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?callerCtx, ?invo).

Temp1(?hctx, ?heap, ?fld, ?calleeCtx, ?firstInsn),
AllPredecessors:StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?calleeCtx, ?firstInsn) <-
   MayCallGraphEdge:ToMethod(?toMethod, ?callerCtx, ?invo),
   MayCallGraphEdge:Context[?callerCtx, ?invo] = ?calleeCtx,
   FirstInstructionOfMethod[?toMethod] = ?firstInsn,
   AllPredecessors:StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?callerCtx, ?invo).

AllPredecessors:CollectionMayPointTo
 (?hctx, ?heap, ?hctxColl, ?collHeap, ?calleeCtx, ?firstInsn) <-
   MayCallGraphEdge:ToMethod(?toMethod, ?callerCtx, ?invo),
   MayCallGraphEdge:Context[?callerCtx, ?invo] = ?calleeCtx,
   FirstInstructionOfMethod[?toMethod] = ?firstInsn,
   AllPredecessors:CollectionMayPointTo
    (?hctx, ?heap, ?hctxColl, ?collHeap, ?callerCtx, ?invo).

MayCallGraphEdge:ToMethodAndContext(?callerCtx, ?invo, ?calleeCtx, ?toMethod) <-
   MayCallGraphEdge:ToMethod(?toMethod, ?callerCtx, ?invo),
   MayCallGraphEdge:Context[?callerCtx, ?invo] = ?calleeCtx.

InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?callerCtx, ?invo) <-
   MayCallGraphEdge:ToMethodAndContext(?callerCtx, ?invo, ?calleeCtx, ?toMethod),
   AllReturn:InstanceFieldMayPointTo
    (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?calleeCtx, ?toMethod).

Temp2(?hctx, ?heap, ?fld, ?callerCtx, ?invo),
StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?callerCtx, ?invo) <-
   MayCallGraphEdge:ToMethodAndContext(?callerCtx, ?invo, ?calleeCtx, ?toMethod),
   AllReturn:StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?calleeCtx, ?toMethod).

CollectionMayPointTo(?hctx, ?heap, ?hctxColl, ?collHeap, ?callerCtx, ?invo) <-
   MayCallGraphEdge:ToMethodAndContext(?callerCtx, ?invo, ?calleeCtx, ?toMethod),
   AllReturn:CollectionMayPointTo
    (?hctx, ?heap, ?hctxColl, ?collHeap, ?calleeCtx, ?toMethod).

_OptStoreInstanceField:From(?insn, ?from) <-
   StoreInstanceField:From[?insn] = ?from.

_OptStoreInstanceField:Base(?insn, ?base) <-
   StoreInstanceField:Base[?insn] = ?base.

StoreFromVarMayPointTo(?hctx, ?heap, ?ctx, ?insn) <-
   MayPointTo(?hctx, ?heap, ?ctx, ?from),
   _OptStoreInstanceField:From(?insn, ?from).

StoreBaseMayPointTo(?hctx, ?heap, ?ctx, ?insn) <-
   MayPointTo(?hctx, ?heap, ?ctx, ?base),
   _OptStoreInstanceField:Base(?insn, ?base).

// store instructions, weak update: info gets *added* to previous. Can
// turn into strong with must info. Need to have
// InstanceFieldMayPointTo before the instruction. See also frame rules.
InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn) <-
   AllPredecessors:InstanceFieldMayPointTo(_, _, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn),
   StoreFromVarMayPointTo(?hctx, ?heap, ?ctx, ?insn),
   StoreBaseMayPointTo(?hctxBase, ?baseHeap, ?ctx, ?insn),
   FieldInstruction:Signature[?insn] = ?fld.

/*
// load instructions
/// UNSOUND!!! Need to know the upper bounds of *all* objects that ?base points to.
MayPointTo(?hctx, ?heap, ?ctx, ?to) <-
   LoadInstanceField:Base[?insn] = ?base,
   LoadInstanceField:To[?insn] = ?to,
   FieldInstruction:Signature[?insn] = ?fld,
   AllPredecessors:InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn),
   MayPointTo(?hctxBase, ?baseHeap, ?ctx, ?base).
// TODO: how is the above not horrible indexing? Is it so small? Same for array loads.
*/

// Sound (but conservative) fix.
MayPointTo(?hctx, ?heap, ?ctx, ?to) <-
   LoadInstanceField:Base[?insn] = ?base,
   LoadInstanceField:To[?insn] = ?to,
   FieldInstruction:Signature[?insn] = ?fld,
   AllPredecessors:InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn),
   _MustPointTo:Object[?ctx, ?base] = ?baseHeap,
   _MustPointTo:Hctx[?ctx, ?base] = ?hctxBase.


_OptStoreStaticField:From(?insn, ?from) <-
   StoreStaticField:From[?insn] = ?from.

StaticStoreFromVarMayPointTo(?hctx, ?heap, ?ctx, ?insn) <-
   MayPointTo(?hctx, ?heap, ?ctx, ?from),
   _OptStoreStaticField:From(?insn, ?from).

// static store instructions. Strong update this time. No frame rule to
// carry on the original info.
StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn) <-
   FieldInstruction:Signature[?insn] = ?fld,
   StaticStoreFromVarMayPointTo(?hctx, ?heap, ?ctx, ?insn).

// static load instructions
Temp3(?hctx, ?heap, ?ctx, ?to),
MayPointTo(?hctx, ?heap, ?ctx, ?to) <-
   LoadStaticField:To[?insn] = ?to,
   FieldInstruction:Signature[?insn] = ?fld,
   AllPredecessors:StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn).

_OptMethodFromVar[?var] = ?method <-
   Var:DeclaringMethod(?var, ?method).

// Final static fields that must point to an object, at the end of a
// class initializer, cannot change in the future; thus, we can make
// closed-world assumptions about the field.
StaticFinalFieldMayPointTo(?hctx, ?heap, ?fld) <-
   AllReturn:StaticFieldMayPointTo(?hctx, ?heap, ?fld, InitialMayContext[], ?meth),
   MethodSignature:SimpleName[?meth] = "<clinit>",
   FieldModifier(Modifier:final[], ?fld).

_OptFieldInstruction:Signature(?insn, ?fld) <-
   FieldInstruction:Signature[?insn] = ?fld.

MayPointTo(?hctx, ?heap, ?ctx, ?to) <-
   LoadStaticField:To[?insn] = ?to,
   _OptFieldInstruction:Signature(?insn, ?fld),
   StaticFinalFieldMayPointTo(?hctx, ?heap, ?fld),
   _OptMethodFromVar[?to] = ?inMeth,
   ReachableMethodUnderMayContext(?ctx, ?inMeth).


// collection loads and stores. For arrays and library collections.
//// TODO: model iterators
LibraryCollectionStoreOperation(?invo) -> MethodInvocation(?invo).
LibraryCollectionLoadOperation(?invo) -> MethodInvocation(?invo).
LibraryCollectionStoreOperation(?invo) <-
   VirtualMethodInvocation:SimpleName[?invo] = "add"; 
   VirtualMethodInvocation:SimpleName[?invo] = "push"; 
   VirtualMethodInvocation:SimpleName[?invo] = "set"; 
   VirtualMethodInvocation:SimpleName[?invo] = "put".
LibraryCollectionLoadOperation(?invo) <-
   VirtualMethodInvocation:SimpleName[?invo] = "peek",
   VirtualMethodInvocation:SimpleName[?invo] = "pop",
   VirtualMethodInvocation:SimpleName[?invo] = "elementAt",
   VirtualMethodInvocation:SimpleName[?invo] = "firstElement",
   VirtualMethodInvocation:SimpleName[?invo] = "lastElement",
   VirtualMethodInvocation:SimpleName[?invo] = "remove",
   VirtualMethodInvocation:SimpleName[?invo] = "get". // TODO: better match in future

StoreCollection:From(?insn, ?from) <-
   StoreArrayIndex:From[?insn] = ?from.
StoreCollection:From(?invo, ?from) <-
   LibraryCollectionStoreOperation(?invo),
   (ActualParam[1, ?invo] = ?from;
    ActualParam[2, ?invo] = ?from).

StoreCollection:Base(?insn, ?var) <-
   StoreArrayIndex:Base[?insn] = ?var.
StoreCollection:Base(?invo, ?var) <-
   LibraryCollectionStoreOperation(?invo),
   VirtualMethodInvocation:Base[?invo] = ?var.

CollectionStoreFromVarMayPointTo(?hctx, ?heap, ?ctx, ?insn) <-
   MayPointTo(?hctx, ?heap, ?ctx, ?from),
   StoreCollection:From(?insn, ?from).

CollectionStoreBaseMayPointTo(?hctxColl, ?collHeap, ?ctx, ?insn) <-
   MayPointTo(?hctxColl, ?collHeap, ?ctx, ?base),
   StoreCollection:Base(?insn, ?base).

// Just like instance field: need to know over-estimate to add more. Also
// frame rule (later) to propagate existing.
CollectionMayPointTo(?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?insn) <-
   AllPredecessors:CollectionMayPointTo(_, _, ?hctxColl, ?collHeap, ?ctx, ?insn),
   CollectionStoreFromVarMayPointTo(?hctx, ?heap, ?ctx, ?insn),
   CollectionStoreBaseMayPointTo(?hctxColl, ?collHeap, ?ctx, ?insn).


// now loads
LoadCollection:To[?insn] = ?to <-
   LoadArrayIndex:To[?insn] = ?to.
LoadCollection:To[?invo] = ?to <-
   LibraryCollectionLoadOperation(?invo),
   AssignReturnValue[?invo] = ?to.

LoadCollection:Base(?insn, ?var) <-
   LoadArrayIndex:Base[?insn] = ?var.
LoadCollection:Base(?invo, ?var) <-
   LibraryCollectionLoadOperation(?invo),
   VirtualMethodInvocation:Base[?invo] = ?var.

/*
CollectionLoadBaseMayPointTo(?hctxColl, ?collHeap, ?ctx, ?insn) <-
   MayPointTo(?hctxColl, ?collHeap, ?ctx, ?base),
   LoadCollection:Base(?insn, ?base).

/// UNSOUND!!!
Temp5(?hctx, ?heap, ?ctx, ?to),
MayPointTo(?hctx, ?heap, ?ctx, ?to) <-
   LoadCollection:To[?insn] = ?to,
   AllPredecessors:CollectionMayPointTo(?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?insn),
   CollectionLoadBaseMayPointTo(?hctxColl, ?collHeap, ?ctx, ?insn).
*/

CollectionLoadBaseMustPointTo(?hctxColl, ?collHeap, ?ctx, ?insn) <-
   _MustPointTo:Object[?ctx, ?base] = ?collHeap,
   _MustPointTo:Hctx[?ctx, ?base] = ?hctxColl,
   LoadCollection:Base(?insn, ?base).

// Sound (but conservative) fix.
MayPointTo(?hctx, ?heap, ?ctx, ?to) <-
   LoadCollection:To[?insn] = ?to,
   AllPredecessors:CollectionMayPointTo(?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?insn),
   CollectionLoadBaseMustPointTo(?hctxColl, ?collHeap, ?ctx, ?insn).


//// ====================================
//// Weakening rules

AllCtxMayPointToInMethod(?hctx, ?heap, ?var, ?method) <-
   MayPointTo(?hctx, ?heap, InitialMayContext[], ?var),
   _OptMethodFromVar[?var] = ?method.

MayPointTo(?hctx, ?heap, ?ctx, ?var) <-
   ReachableMethodUnderMayContext(?ctx, ?method),
   AllCtxMayPointToInMethod(?hctx, ?heap, ?var, ?method).

AllCtxInstanceFieldMayPointToInMethod
  (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?insn, ?method) <-
   InstanceFieldMayPointTo
    (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, InitialMayContext[], ?insn),
   Instruction:Method[?insn] = ?method.

InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn) <-
   ReachableMethodUnderMayContext(?ctx, ?method),
   AllCtxInstanceFieldMayPointToInMethod
    (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?insn, ?method).

StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn) <-
   Instruction:Method[?insn] = ?method,
   ReachableMethodUnderMayContext(?ctx, ?method),
   StaticFieldMayPointTo(?hctx, ?heap, ?fld, InitialMayContext[], ?insn).

AllCtxCollectionMayPointToInMethod(?hctx, ?heap, ?hctxColl, ?collHeap, ?insn, ?method) <-
   CollectionMayPointTo(?hctx, ?heap, ?hctxColl, ?collHeap, InitialMayContext[], ?insn),
   Instruction:Method[?insn] = ?method.

CollectionMayPointTo(?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?insn) <-
   ReachableMethodUnderMayContext(?ctx, ?method),
   AllCtxCollectionMayPointToInMethod(?hctx, ?heap, ?hctxColl, ?collHeap, ?insn, ?method).

_AllCtxMustPointToInMethod(?hctx, ?heap, ?var, ?method) <-
   _MustPointTo:Object[InitialMayContext[], ?var] = ?heap,
   _MustPointTo:Hctx[InitialMayContext[], ?var] = ?hctx,
   _OptMethodFromVar[?var] = ?method.

_MustPointTo:Object[?ctx, ?var] = ?heap,
_MustPointTo:Hctx[?ctx, ?var] = ?hctx <-
   ReachableMethodUnderMayContext(?ctx, ?method),
   _AllCtxMustPointToInMethod(?hctx, ?heap, ?var, ?method).

AllCtxIntraproceduralMustPointToInMethod(?hctx, ?heap, ?var, ?method) <-
   IntraproceduralMustPointTo:Object[InitialMayContext[], ?var] = ?heap,
   IntraproceduralMustPointTo:Hctx[InitialMayContext[], ?var] = ?hctx,
   _OptMethodFromVar[?var] = ?method.

IntraproceduralMustPointTo:Object[?ctx, ?var] = ?heap,
IntraproceduralMustPointTo:Hctx[?ctx, ?var] = ?hctx <-
   ReachableMethodUnderMayContext(?ctx, ?method),
   AllCtxIntraproceduralMustPointToInMethod(?hctx, ?heap, ?var, ?method).

//// ====================================
//// BEGIN frame rules

// TODO: also, for freshly allocated objects, it should be enough to have
//       instance field points-to information for one path. The object doesn't
//       exist in others. This needs escape reasoning? The object may come back
//       to the same program point through the other path.

InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn) <-
   AllPredecessors:InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn),
   (!MethodInvocation(?insn);
    IgnorableMethodInvocation(?insn);
	IgnorableForNonCollectionsMethodInvocation(?insn)),
   (!StoreInstanceField:Insn(?insn); FieldInstruction:Signature[?insn] != ?fld).

// Handling final fields incurs overhead: too much info carried everywhere.
// REVIEW: Consider not including to balance speed/coverage.
InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn) <-
   AllPredecessors:InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn),
   FieldModifier(Modifier:final[], ?fld).

// A stunning frame rule for sound-may: if we have an overapproximation of what the
// store instruction updates, then all past information on the same field can be kept.
InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn) <-
   AllPredecessors:InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn),
   StoreFromVarMayPointTo(_, _, ?ctx, ?insn),
   StoreBaseMayPointTo(_, _, ?ctx, ?insn),
   FieldInstruction:Signature[?insn] = ?fld.

StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn) <-
   AllPredecessors:StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn),
   (!MethodInvocation(?insn);
    IgnorableMethodInvocation(?insn);
	IgnorableForNonCollectionsMethodInvocation(?insn);
	IgnorableMethodInvocationForStatic(?insn)),
   (!StoreStaticField:Insn(?insn); FieldInstruction:Signature[?insn] != ?fld).

// REVIEW: final fields (see above)
StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn) <-
   AllPredecessors:StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn),
   FieldModifier(Modifier:final[], ?fld).

// Note the *absence* of a frame rule to keep the old
// StaticFieldPointsTo information when the same field is
// updated. This yields strong updates for static fields.

// Much like instance fields
CollectionMayPointTo(?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?insn) <-
   AllPredecessors:CollectionMayPointTo(?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?insn),
   (!MethodInvocation(?insn);
    IgnorableMethodInvocation(?insn);
	LibraryCollectionLoadOperation(?insn)),
   !StoreArrayIndex:Insn(?insn).

Temp6(?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?insn),
CollectionMayPointTo(?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?insn) <-
   AllPredecessors:CollectionMayPointTo(?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?insn),
   CollectionStoreFromVarMayPointTo(_, _, ?ctx, ?insn),
   CollectionStoreBaseMayPointTo(_, _, ?ctx, ?insn).

// if it's a non-array operation on collections but the info concerns an array
CollectionMayPointTo(?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?insn) <-
   AllPredecessors:CollectionMayPointTo(?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?insn),
   ArrayType(HeapAllocation:Type[?collHeap]),
   LibraryCollectionStoreOperation(?insn).

// and the converse. TODO: more fine-grained distinction of library collections?
CollectionMayPointTo(?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?insn) <-
   AllPredecessors:CollectionMayPointTo(?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?insn),
   LibraryCollectionType(HeapAllocation:Type[?collHeap]),
   StoreArrayIndex:Insn(?insn).


// Some calls to native or otherwise complex methods need to be
// modeled, i.e., ignored. E.g., fillInStackTrace is a native method
// called in the constructor of a (ubiquitous) java.lang.Throwable. If
// not ignored, no image of the heap propagates anywhere.
// TODO: do a better match (on full sig) than just on SimpleName.
IgnorableMethodInvocation(?invo) -> MethodInvocation(?invo).
IgnorableMethodInvocationForStatic(?invo) -> MethodInvocation(?invo).
IgnorableForNonCollectionsMethodInvocation(?invo) -> MethodInvocation(?invo).

IgnorableMethodInvocation(?invo) <-
   VirtualMethodInvocation:SimpleName[?invo] = "fillInStackTrace"; // Throwable
   VirtualMethodInvocation:SimpleName[?invo] = "equals";  // Object
   VirtualMethodInvocation:SimpleName[?invo] = "hashCode";
   VirtualMethodInvocation:SimpleName[?invo] = "toString";
   VirtualMethodInvocation:SimpleName[?invo] = "println"; // PrintStream
   StaticMethodInvocation:SimpleName[?invo] = "parseInt"; // Integer
   VirtualMethodInvocation:SimpleName[?invo] = "endsWith"; // String
   StaticMethodInvocation:SimpleName[?invo] = "floatToRawIntBits"; // Float
   // these are used in the HashMap "put" method!
   StaticMethodInvocation:SimpleName[?invo] = "intBitsToFloat"; 
   // From this point on, it's just a test to see if these natives matter.
   StaticMethodInvocation:SimpleName[?invo] = "encoding"; // Console
   StaticMethodInvocation:SimpleName[?invo] = "echo"; 
   StaticMethodInvocation:SimpleName[?invo] = "istty"; 
   VirtualMethodInvocation:SimpleName[?invo] = "sync"; // FileDescriptor
   StaticMethodInvocation:SimpleName[?invo] = "initIDs"; 
   VirtualMethodInvocation:SimpleName[?invo] = "open"; // FileInputStream
   VirtualMethodInvocation:SimpleName[?invo] = "read0"; 
   VirtualMethodInvocation:SimpleName[?invo] = "readBytes"; 
   VirtualMethodInvocation:SimpleName[?invo] = "skip"; 
   VirtualMethodInvocation:SimpleName[?invo] = "available"; 
   VirtualMethodInvocation:SimpleName[?invo] = "close0"; 
   VirtualMethodInvocation:SimpleName[?invo] = "write"; // FileOutputStream
   VirtualMethodInvocation:SimpleName[?invo] = "writeBytes"; 
   VirtualMethodInvocation:SimpleName[?invo] = "availableProcessors"; // Runtime
   VirtualMethodInvocation:SimpleName[?invo] = "freeMemory"; 
   VirtualMethodInvocation:SimpleName[?invo] = "totalMemory"; 
   VirtualMethodInvocation:SimpleName[?invo] = "maxMemory"; 
   VirtualMethodInvocation:SimpleName[?invo] = "gc"; 
   StaticMethodInvocation:SimpleName[?invo] = "runFinalization0"; 
   StaticMethodInvocation:SimpleName[?invo] = "sin"; // StrictMath
   StaticMethodInvocation:SimpleName[?invo] = "cos"; 
   StaticMethodInvocation:SimpleName[?invo] = "tan"; 
   StaticMethodInvocation:SimpleName[?invo] = "log"; 
   StaticMethodInvocation:SimpleName[?invo] = "pow";
   StaticMethodInvocation:SimpleName[?invo] = "currentThread"; // Thread
   StaticMethodInvocation:SimpleName[?invo] = "yield";
   StaticMethodInvocation:SimpleName[?invo] = "sleep";
   VirtualMethodInvocation:SimpleName[?invo] = "start0";
   VirtualMethodInvocation:SimpleName[?invo] = "isInterrupted";
   VirtualMethodInvocation:SimpleName[?invo] = "isAlive";
   StaticMethodInvocation:SimpleName[?invo] = "holdsLock";
   StaticMethodInvocation:SimpleName[?invo] = "getThreads";
   StaticMethodInvocation:SimpleName[?invo] = "dumpThreads";
   VirtualMethodInvocation:SimpleName[?invo] = "setPriority";
   VirtualMethodInvocation:SimpleName[?invo] = "stop0";
   VirtualMethodInvocation:SimpleName[?invo] = "suspend0";
   VirtualMethodInvocation:SimpleName[?invo] = "resume0";
   VirtualMethodInvocation:SimpleName[?invo] = "interrupt0";
   VirtualMethodInvocation:SimpleName[?invo] = "isAlive";
   VirtualMethodInvocation:SimpleName[?invo] = "getStackTraceDepth"; // Throwable
   VirtualMethodInvocation:SimpleName[?invo] = "getStackTraceElement"; 
   VirtualMethodInvocation:SimpleName[?invo] = "forkAndExec";  // UnixProcess
   VirtualMethodInvocation:SimpleName[?invo] = "wait"; // Object
   VirtualMethodInvocation:SimpleName[?invo] = "notify";
   VirtualMethodInvocation:SimpleName[?invo] = "notifyAll".

IgnorableMethodInvocationForStatic(?invo) <-
   VirtualMethodInvocation:SimpleName[?invo] = "intern"; // String
   VirtualMethodInvocation:SimpleName[?invo] = "clone"; // Object
   VirtualMethodInvocation:SimpleName[?invo] = "append". // StringBuilder

IgnorableForNonCollectionsMethodInvocation(?invo) <-
   LibraryCollectionStoreOperation(?invo);
   LibraryCollectionLoadOperation(?invo).


StaticMethodInvocation:SimpleName[?invocation] = ?simplename <-
   MethodInvocation:Signature[?invocation] = ?signature,
   StaticMethodInvocation:Insn(?invocation),
   MethodSignature:SimpleName[?signature] = ?simplename.

/*
//// Commented out for now. Does not make that much difference. 
//// InstanceFieldMayPointTo inferences rarely get stopped because of
//// library calls.
//// ------------------------------
// Logic for assuming the library does not affect application fields,
// except via reflection.
ApplicationField(?fld) <-
   FieldSignature:DeclaringClass[?fld] = ?class,
   ApplicationClass(?class).

ApplicationMethod(?meth) <-
   MethodSignature:DeclaringType[?meth] = ?declaringType,
   ApplicationClass(?declaringType).

MethodCallsReflection(?meth) <-
   Instruction:Method[?invo] = ?meth,
   MethodInvocation:Signature[?invo] = ?sig,
   string:substring[?sig, 0, _] = "<java.lang.reflect".

_Opt2MethodInvocation:Signature(?invo, ?inMeth, ?toMeth) <-
   (StaticMethodInvocation:Insn(?invo);
    SpecialMethodInvocation:Insn(?invo)), 
   MethodInvocation:Signature[?invo] = ?toMeth,
   Instruction:Method[?invo] = ?inMeth.

// exact resolution for static/special
MethodCallsReflection(?inMeth) <-
   _Opt2MethodInvocation:Signature(_, ?inMeth, ?toMeth), 
   MethodCallsReflection(?toMeth).

// underapproximation of virtual method resolution, as if static
_Opt2MethodInvocation:Signature(?invo, ?inMeth, ?toMeth) <-
   VirtualMethodInvocation:Insn(?invo),
   MethodInvocation:Signature[?invo] = ?toMeth,
   Instruction:Method[?invo] = ?inMeth.

// Naive virtual method resolution, based on name. REVIEW: too conservative?
_OptVirtualMethodInvocation:Simplename(?inMeth, ?simpleName) <-
   VirtualMethodInvocation:SimpleName[?invo] = ?simpleName,
   Instruction:Method[?invo] = ?inMeth.

MethodCallsReflection(?inMeth) <-
   MethodCallsReflection(?toMeth),
   MethodSignature:SimpleName[?toMeth] = ?toMethSimpleName,
   _OptVirtualMethodInvocation:Simplename(?inMeth, ?toMethSimpleName).

InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn) <-
   AllPredecessors:InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn),
   MethodInvocation:Signature[?insn] = ?calledMethod, // underapproximate
//   string:substring[?calledMethod, 0, string:length[?str]] != ?str, ?str = "<java.lang.reflect",
   !MethodCallsReflection(?calledMethod),
   ApplicationField(?fld),
   !ApplicationMethod(?calledMethod).

StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn) <-
   AllPredecessors:StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn),
   MethodInvocation:Signature[?insn] = ?calledMethod,
//   string:substring[?calledMethod, 0, string:length[?str]] != ?str, ?str = "<java.lang.reflect",
   !MethodCallsReflection(?calledMethod),
   ApplicationField(?fld),
   !ApplicationMethod(?calledMethod).

// TODO: also extend to collections
*/

/*
//// Unsound HACK! Just during testing, for estimating the impact of
//// better "NonDom" logic.
AllPredecessors:InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn) <-
   AllNonDomPredecessors:InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn).
AllPredecessors:StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn) <-
   AllNonDomPredecessors:StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn).
AllPredecessors:CollectionMayPointTo(?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?insn) <-
   AllNonDomPredecessors:CollectionMayPointTo(?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?insn).
*/



/*
//// TODO: Why not base this logic on a type-based escape analysis?
//// TODO
//// ====================================
//// Logic for computing the highly useful concepts of "Method/Call
//// Does Not Invalidate Field"

MethodDirectlyInvalidatesField(?fld, ?inMeth) <-
   FieldInstruction:Signature[?insn] = ?fld,
   Instruction:Method[?insn] = ?inMeth.

OptInvocationInsn(?insn, ?method) <-
   Instruction:Method[?insn] = ?method,
   MethodInvocation(?insn).

HigherIndexInvocationInMethod(?invo, ?indexHigher) <-
   OptInvocationInsn(?invo, ?inMeth),
   OptInvocationInsn(?higherInvo, ?inMeth),
   Instruction:Index[?higherInvo] = ?indexHigher,
   Instruction:Index[?invo] < ?indexHigher.   
   
NextInvocationInMethod[?invo] = ?nextInvo <-
   agg<<?nextInvo = 
      min(?index)>>(HigherIndexInvocationInMethod(?invo, ?index)).

DefiniteInvocation[?invo] = ?toMethod <-
   (SpecialMethodInvocation:Insn(?invo);
    StaticMethodInvocation:Insn(?invo)),
   MethodInvocation:Signature[?invo] = ?toMethod.

MethodCallsUnknown(?method) <-
   Instruction:Method[?insn] = ?method,
   VirtualMethodInvocation:Insn(?insn).

MethodHasCalls(?method) <-
   OptInvocationInsn(_, ?method).
   
AllMethodCallsDefinite(?method) <-
   MethodHasCalls(?method),
   !MethodCallsUnknown(?method).
*/ 




/*
// TODO: currently has no impact. Comment out and re-check when non-invalidating
//       method calls are added?

// Interesting addition to frame rules:
// propagate in case of non-invalidating dominated predecessors.

BasicBlockMayInvalidateFieldPointsTo(?fld, ?headInsn) <-
   BasicBlockHead[?insn] = ?headInsn,
   FieldInstruction:Signature[?insn] = ?fld.

// The path (dominated by ?dominator) that ends at ?insn
// may invalidate some field.
DominatedPathMayInvalidateFieldPointsTo(?fld, ?insn, ?dominator) <-
   Dominates(?dominator, ?insn),
   BasicBlockMayInvalidateFieldPointsTo(?fld, ?insn).

DominatedPathMayInvalidateFieldPointsTo(?fld, ?insn, ?dominator) <-
   DominatedPathMayInvalidateFieldPointsTo(?fld, ?otherInsn, ?dominator),
   MaySuccessorBBModuloThrow(?insn, ?otherInsn),
   Dominates(?dominator, ?insn).

ExistsFieldInvalidatingPathToPredecessor(?fld, ?prevHead, ?dominator) <-
   DominatesItsPredecessorInstruction(?prevInsn, ?dominator),
   BasicBlockHead[?prevInsn] = ?prevHead,
   DominatedPathMayInvalidateFieldPointsTo(?fld, ?prevHead, ?dominator).

ExistsFieldInvalidatingPathToSomePredecessor(?fld, ?dominator) <-
   ExistsFieldInvalidatingPathToPredecessor(?fld, _, ?dominator).

BasicBlockMayInvalidateAllFieldsPointsTo(?headInsn) <-
   BasicBlockHead[?insn] = ?headInsn,
   !IndifferentInstruction(?insn),
   !FieldInstruction(?insn).

// The path (dominated by ?dominator) that ends at ?insn
// may invalidate any field.
DominatedPathMayInvalidateAllFieldsPointsTo(?insn, ?dominator) <-
   Dominates(?dominator, ?insn),
   BasicBlockMayInvalidateAllFieldsPointsTo(?insn).

DominatedPathMayInvalidateAllFieldsPointsTo(?insn, ?dominator) <-
   DominatedPathMayInvalidateAllFieldsPointsTo(?otherInsn, ?dominator),
   MaySuccessorBBModuloThrow(?insn, ?otherInsn),
   Dominates(?dominator, ?insn).

ExistsAllFieldsInvalidatingPathToPredecessor(?prevHead, ?dominator) <-
   DominatesItsPredecessorInstruction(?prevInsn, ?dominator),
   BasicBlockHead[?prevInsn] = ?prevHead,
   DominatedPathMayInvalidateAllFieldsPointsTo(?prevHead, ?dominator).

ExistsAllFieldsInvalidatingPathToSomePredecessor(?dominator) <-
   ExistsAllFieldsInvalidatingPathToPredecessor(_, ?dominator).

InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn) <-
   AllNonDomPredecessors:InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn),
   !ExistsFieldInvalidatingPathToSomePredecessor(?fld, ?insn),
   !ExistsAllFieldsInvalidatingPathToSomePredecessor(?insn),
   DominatesItsPredecessorInstruction(_, ?insn).

StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn) <-
   AllNonDomPredecessors:StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn),
   !ExistsFieldInvalidatingPathToSomePredecessor(?fld, ?insn),
   !ExistsAllFieldsInvalidatingPathToSomePredecessor(?insn),
   DominatesItsPredecessorInstruction(_, ?insn).

// TODO: update with collections
*/


//// END frame rules

//// ====================================
//// BEGIN context management

// Heap contexts
MayHeapContext(?hctx) ->.
lang:entity(`MayHeapContext).
lang:physical:storageModel[`MayHeapContext]="ScalableSparse".
lang:physical:capacity[`MayHeapContext] = 8388608.

EmptyHeapContext[] = ?hctx -> MayHeapContext(?hctx).
lang:skolem(`EmptyHeapContext).
EmptyHeapContext[] = ?hctx, MayHeapContext(?hctx)  <- .

// #define RecordMacroMay(ctx,heap,hctx) \
//   MayHeapContext(hctx), \
//   EmptyHeapContext[] = hctx


// Calling contexts
MayContext(?ctx) ->.
lang:entity(`MayContext).
lang:physical:storageModel[`MayContext]="ScalableSparse".
lang:physical:capacity[`MayContext] = 4294967296.

InitialMayContext[] = ?ctx -> MayContext(?ctx).
lang:skolem(`InitialMayContext).
InitialMayContext[] = ?ctx, MayContext(?ctx)  <- .

PushMayContext[?invo, ?ctx] = ?pushedCtx ->
   MayContext(?pushedCtx), MayContext(?ctx), CallGraphEdgeSource(?invo).
lang:skolem(`PushMayContext).

/*
//// Currently unused
PopMayContext[?ctx] = ?poppedCtx ->
   MayContext(?poppedCtx), MayContext(?ctx).
MayContextContains(?invo, ?ctx) ->
   MayContext(?ctx), CallGraphEdgeSource(?invo).
MayContextContains(?invo, ?ctx),
PopMayContext[?ctx] = ?poppedCtx <-
   PushMayContext[?invo, ?poppedCtx] = ?ctx.
MayContextContains(?invo, ?ctx) <-
   PushMayContext[_, ?poppedCtx] = ?ctx,
   MayContextContains(?invo, ?poppedCtx).
*/

MayContextDepth[?ctx] = ?depth ->
   MayContext(?ctx), int[32](?depth).
MayContextDepth[?ctx] = ?depth+1 <-
   PushMayContext[_, ?poppedCtx] = ?ctx,
   MayContextDepth[?poppedCtx] = ?depth.
MayContextDepth[?ctx] = 0 <-
   InitialMayContext[] = ?ctx.

MaxMayContextDepth[] = ?num -> int[32](?num).

//// END context management


//// ====================================
//// BEGIN configuration
////  Different ways to kick-start the analysis.

MaxMayContextDepth[] = 6 <- .

RootMethodForMayAnalysis(?meth) <-
   MethodSignature:DeclaringType[?meth] = ?class, ApplicationClass(?class).

// Try to discover hidden "main" heuristically
AppMainMethod(?mainMeth) <-
   MethodSignature:SimpleName[?mainMeth] = "main",
   MethodSignature:DeclaringType[?mainMeth] = ?class,
   ApplicationClass(?class).

// Heuristic: if you can reach it in the analysis and it's a static
// initializer, start a new search (with zero context depth) from it.
// There are lots of static final fields in the library that see heavy
// use.
ClinitMethodOfClass(?meth, ?class) <-
   MethodSignature:SimpleName[?meth] = "<clinit>",
   MethodSignature:DeclaringType[?meth] = ?class.
   
RootMethodForMayAnalysis(?clinitMeth) <-
   ReachableMethodUnderMayContext(_, ?meth),
   MethodSignature:DeclaringType[?meth] = ?class,
   ClinitMethodOfClass(?clinitMeth, ?class).

/*
RootMethodForMayAnalysis(?meth) <-
   ReachableMethodUnderMayContext(_, ?meth).
*/

/*
RootMethodForMayAnalysis(?meth) <-
   AppMainMethod(?meth).

// Heuristic: if you can reach it in the analysis and it's an app
// method, start a new search (with zero context depth) from it.
RootMethodForMayAnalysis(?meth) <-
   ReachableMethodUnderMayContext(_, ?meth),
   MethodSignature:DeclaringType[?meth] = ?class,
   ApplicationClass(?class).
*/


// For the legit, official main of a standard Java program, provide
// dummy argument (String[] args).
MayPointTo(?hctx, ?argsArray, ?ctx, ?args),
AllPredecessors:CollectionMayPointTo(?hctx, ?argHeap, ?hctx, ?argsArray, ?ctx, ?firstInsn) <-
   MainClass(?mainClass),
   MethodSignature:DeclaringType[?mainMethod] = ?mainClass,
   ReachableMethodUnderMayContext(?ctx, ?mainMethod),
   MethodSignature:Descriptor[?mainMethod] = "void(java.lang.String[])",
   FormalParam[0, ?mainMethod] = ?args,
   MainMethodArgsArray(?argsArray),
   MainMethodArgHeap(?argHeap),
   ?hctx = EmptyHeapContext[],
   FirstInstructionOfMethod[?mainMethod] = ?firstInsn.


// At the beginning of "main", all static fields of classes are
// assumed to point to null. This is sound (even though <clinit>s will
// be called whenever)!  It is an overestimate of what's true.
StaticFieldOfMayReachableClass(?fld) <-
   ReachableMethodUnderMayContext(_, ?meth),
   MethodSignature:DeclaringType[?meth] = ?class,
//   ApplicationClass(?class),
   _OptFieldFromClass(?fld, ?class),
   FieldModifier(Modifier:static[], ?fld),
   FieldSignature:Type[?fld] = ?fldType,
   ReferenceType(?fldType).

MayHeapContext(?hctx), EmptyHeapContext[] = ?hctx,
AllPredecessors:StaticFieldMayPointTo(?hctx, ?nullHeap, ?fld, InitialMayContext[], ?firstInsn) <-
//   MainMethodDeclaration(?mainMeth),
   AppMainMethod(?mainMeth),
   FirstInstructionOfMethod[?mainMeth] = ?firstInsn,
   StaticFieldOfMayReachableClass(?fld),
   HeapAllocation:Null[] = ?nullHeap.


//// END configuration


//// ====================================
//// AUXILIARY. Helper relations, "forall" emulations.

// For all Phi node instructions, the "to" var (implicit in the
// predicate) may point to...
MayPointToUpToPhiInstruction(?hctx, ?heap, ?ctx, ?insn) ->
   MayHeapContext(?hctx), HeapAllocation(?heap), MayContext(?ctx), 
   Instruction(?insn).

MayPointToUpToPhiInstruction(?hctx, ?heap, ?ctx, ?headInsn) <-
   PhiNodeHead[_] = ?headInsn,
   AssignLocal:From[?headInsn] = ?from,
   MayPointTo(?hctx, ?heap, ?ctx, ?from).

MayPointToUpToPhiInstruction(?hctx1, ?heap1, ?ctx, ?nextInsn),
MayPointToUpToPhiInstruction(?hctx2, ?heap2, ?ctx, ?nextInsn) <-
   MayPointToUpToPhiInstruction(?hctx1, ?heap1, ?ctx, ?insn),
   NextInSamePhiNode[?insn] = ?nextInsn,
   AssignLocal:From[?nextInsn] = ?from,
   MayPointTo(?hctx2, ?heap2, ?ctx, ?from).

// Same for the special case of _MustPointTo
_MustPointToUpToPhiInstruction:Object[?ctx, ?insn] = ?heap ->
   HeapAllocation(?heap), MayContext(?ctx), Instruction(?insn).
_MustPointToUpToPhiInstruction:Hctx[?ctx, ?insn] = ?hctx -> 
   MayHeapContext(?hctx), MayContext(?ctx), Instruction(?insn).

_MustPointToUpToPhiInstruction:Object[?ctx, ?headInsn] = ?heap,
_MustPointToUpToPhiInstruction:Hctx[?ctx, ?headInsn] = ?hctx  <-
   PhiNodeHead[_] = ?headInsn,
   AssignLocal:From[?headInsn] = ?from,
   _MustPointTo:Object[?ctx, ?from] = ?heap,
   _MustPointTo:Hctx[?ctx, ?from] = ?hctx.

_MustPointToUpToPhiInstruction:Object[?ctx, ?nextInsn] = ?heap,
_MustPointToUpToPhiInstruction:Hctx[?ctx, ?nextInsn] = ?hctx <-
   _MustPointToUpToPhiInstruction:Object[?ctx, ?insn] = ?heap,
   _MustPointToUpToPhiInstruction:Hctx[?ctx, ?insn] = ?hctx,
   NextInSamePhiNode[?insn] = ?nextInsn,
   AssignLocal:From[?nextInsn] = ?from,
   _MustPointTo:Object[?ctx, ?from] = ?heap,
   _MustPointTo:Hctx[?ctx, ?from] = ?hctx.

// duplicate of above
IntraproceduralMustPointToUpToPhiInstruction:Object[?ctx, ?insn] = ?heap ->
   HeapAllocation(?heap), MayContext(?ctx), Instruction(?insn).
IntraproceduralMustPointToUpToPhiInstruction:Hctx[?ctx, ?insn] = ?hctx -> 
   MayHeapContext(?hctx), MayContext(?ctx), Instruction(?insn).

IntraproceduralMustPointToUpToPhiInstruction:Object[?ctx, ?headInsn] = ?heap,
IntraproceduralMustPointToUpToPhiInstruction:Hctx[?ctx, ?headInsn] = ?hctx  <-
   PhiNodeHead[_] = ?headInsn,
   AssignLocal:From[?headInsn] = ?from,
   IntraproceduralMustPointTo:Object[?ctx, ?from] = ?heap,
   IntraproceduralMustPointTo:Hctx[?ctx, ?from] = ?hctx.

IntraproceduralMustPointToUpToPhiInstruction:Object[?ctx, ?nextInsn] = ?heap,
IntraproceduralMustPointToUpToPhiInstruction:Hctx[?ctx, ?nextInsn] = ?hctx <-
   IntraproceduralMustPointToUpToPhiInstruction:Object[?ctx, ?insn] = ?heap,
   IntraproceduralMustPointToUpToPhiInstruction:Hctx[?ctx, ?insn] = ?hctx,
   NextInSamePhiNode[?insn] = ?nextInsn,
   AssignLocal:From[?nextInsn] = ?from,
   IntraproceduralMustPointTo:Object[?ctx, ?from] = ?heap,
   IntraproceduralMustPointTo:Hctx[?ctx, ?from] = ?hctx.



// for all returns of a method, the return variable has a known upper bound
// for its points-to, and we take the union of all such bounds
UpToReturnMayPointTo(?hctx, ?heap, ?ctx, ?return) <-
   ReturnInstruction(?return),
   !ExistsPreviousReturn(?return),
   ReturnNonvoid:Var[?return] = ?var,
   MayPointTo(?hctx, ?heap, ?ctx, ?var).

UpToReturnMayPointTo(?hctx1, ?heap1, ?ctx, ?return),
UpToReturnMayPointTo(?hctx2, ?heap2, ?ctx, ?return) <-
   UpToReturnMayPointTo(?hctx1, ?heap1, ?ctx, ?prevReturn),
   NextReturn[?prevReturn] = ?return,
   ReturnNonvoid:Var[?return] = ?var,
   MayPointTo(?hctx2, ?heap2, ?ctx, ?var).

AllReturn:MayPointTo(?hctx, ?heap, ?ctx, ?method) <-
   UpToReturnMayPointTo(?hctx, ?heap, ?ctx, ?return),
   !(NextReturn[?return] = _),
   Instruction:Method[?return] = ?method.

// Same for the special case of _MustPointTo
_UpToReturnMustPointTo:Object[?ctx, ?return] = ?heap,
_UpToReturnMustPointTo:Hctx[?ctx, ?return] = ?hctx <-
   ReturnInstruction(?return),
   !ExistsPreviousReturn(?return),
   ReturnNonvoid:Var[?return] = ?var,
   _MustPointTo:Object[?ctx, ?var] = ?heap,
   _MustPointTo:Hctx[?ctx, ?var] = ?hctx.

_UpToReturnMustPointTo:Object[?ctx, ?return] = ?heap,
_UpToReturnMustPointTo:Hctx[?ctx, ?return] = ?hctx <-
   _UpToReturnMustPointTo:Object[?ctx, ?prevReturn] = ?heap,
   _UpToReturnMustPointTo:Hctx[?ctx, ?prevReturn] = ?hctx,
   NextReturn[?prevReturn] = ?return,
   ReturnNonvoid:Var[?return] = ?var,
   _MustPointTo:Object[?ctx, ?var] = ?heap,
   _MustPointTo:Hctx[?ctx, ?var] = ?hctx.

_AllReturn:MustPointTo:Object[?ctx, ?method] = ?heap,
_AllReturn:MustPointTo:Hctx[?ctx, ?method] = ?hctx <-
   _UpToReturnMustPointTo:Object[?ctx, ?return] = ?heap,
   _UpToReturnMustPointTo:Hctx[?ctx, ?return] = ?hctx,
   !(NextReturn[?return] = _),
   Instruction:Method[?return] = ?method.

/// ----------------------------------


/// InstanceFieldMayPointTo for predecessors

// Up to a certain non-dominated predecessor basic block, there is
// instance field point-to information. We take the union.
InstanceFieldMayPointToUpToNonDomPredecessor(?hctx, ?heap, ?fld, ?hctxBase,
                                             ?baseHeap, ?ctx, ?insn, ?pred) ->
   MayHeapContext(?hctx), HeapAllocation(?heap),
   FieldSignature(?fld), MayHeapContext(?hctxBase),
   HeapAllocation(?baseHeap), MayContext(?ctx), Instruction(?insn), Instruction(?pred).

InstanceFieldMayPointToUpToNonDomPredecessor(?hctx, ?heap, ?fld, ?hctxBase,
                                             ?baseHeap, ?ctx, ?insn, ?pred) <-
   MaySuccessorBBModuloThrow(?insn, ?pred),
   BasicBlockEnd(?tail),
   BasicBlockHead[?tail] = ?pred,
   InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?tail),
   !ExistsPreviousNonDomPredecessorToSameBB(?pred, ?insn).

OptInstanceFieldMayPointToAtNextNonDomPredecessor
 (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn, ?predPrev) <-
   BasicBlockEnd(?tail),
   BasicBlockHead[?tail] = ?pred,
   InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?tail),
   PreviousNonDomPredecessorToSameBB[?insn, ?pred] = ?predPrev.

InstanceFieldMayPointToUpToNonDomPredecessor
 (?hctx1, ?heap1, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn, ?pred),
InstanceFieldMayPointToUpToNonDomPredecessor
 (?hctx2, ?heap2, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn, ?pred) <-
   InstanceFieldMayPointToUpToNonDomPredecessor
    (?hctx1, ?heap1, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn, ?prevPred),
   OptInstanceFieldMayPointToAtNextNonDomPredecessor
    (?hctx2, ?heap2, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn, ?prevPred),
   NextNonDomPredecessorToSameBB[?insn, ?prevPred] = ?pred.

// For all non-dominated predecessor instructions, there is point-to information.
// We take the union.
AllNonDomPredecessors:InstanceFieldMayPointTo
 (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn) ->
   MayHeapContext(?hctx), HeapAllocation(?heap),
   FieldSignature(?fld), MayHeapContext(?hctxBase),
   HeapAllocation(?baseHeap), MayContext(?ctx), Instruction(?insn).
   
AllNonDomPredecessors:InstanceFieldMayPointTo
 (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn) <-
   InstanceFieldMayPointToUpToNonDomPredecessor
    (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn, ?pred),
   !(NextNonDomPredecessorToSameBB[?insn, ?pred] = _),
   !ExceptionHandlerFirstInstruction(?insn).

AllNonDomPredecessors:InstanceFieldMayPointTo
 (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn) <-
   PrevInSameBasicBlock[?insn] = ?prev,
   InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?prev).


// Same as above, for all predecessors (not just non-dominated ones)

// Up to a certain predecessor basic block, there is
// instance field point-to information. We take the union.
InstanceFieldMayPointToUpToPredecessor(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap,
                                       ?ctx, ?insn, ?pred) ->
   MayHeapContext(?hctx), HeapAllocation(?heap),
   FieldSignature(?fld), MayHeapContext(?hctxBase),
   HeapAllocation(?baseHeap), MayContext(?ctx), Instruction(?insn), Instruction(?pred).

InstanceFieldMayPointToUpToPredecessor(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap,
                                       ?ctx, ?insn, ?pred) <-
   MaySuccessorBBModuloThrow(?insn, ?pred),
   BasicBlockEnd(?tail),
   BasicBlockHead[?tail] = ?pred,
   InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?tail),
   !ExistsPreviousPredecessorToSameBB(?pred, ?insn).

OptInstanceFieldMayPointToAtNextPredecessor
 (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn, ?predPrev) <-
   BasicBlockEnd(?tail),
   BasicBlockHead[?tail] = ?pred,
   InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?tail),
   PreviousPredecessorToSameBB[?insn, ?pred] = ?predPrev.

InstanceFieldMayPointToUpToPredecessor
 (?hctx1, ?heap1, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn, ?pred),
InstanceFieldMayPointToUpToPredecessor
 (?hctx2, ?heap2, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn, ?pred) <-
   InstanceFieldMayPointToUpToPredecessor
    (?hctx1, ?heap1, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn, ?prevPred),
   OptInstanceFieldMayPointToAtNextPredecessor
    (?hctx2, ?heap2, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn, ?prevPred),
   NextPredecessorToSameBB[?insn, ?prevPred] = ?pred.

// For all predecessor instructions, there is point-to information.
// We take the union.
AllPredecessors:InstanceFieldMayPointTo
 (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn) ->
   MayHeapContext(?hctx), HeapAllocation(?heap),
   FieldSignature(?fld), MayHeapContext(?hctxBase),
   HeapAllocation(?baseHeap), MayContext(?ctx), Instruction(?insn).
   
AllPredecessors:InstanceFieldMayPointTo
 (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn) <-
   InstanceFieldMayPointToUpToPredecessor
    (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn, ?pred),
   !(NextPredecessorToSameBB[?insn, ?pred] = _),
   !ExceptionHandlerFirstInstruction(?insn).

AllPredecessors:InstanceFieldMayPointTo
 (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?insn) <-
   PrevInSameBasicBlock[?insn] = ?prev,
   InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?prev).

/// ----------------------------------


/// StaticFieldMayPointTo for predecessors

// Up to a certain non-dominated predecessor basic block, there is
// static field point-to information. We take the union.
StaticFieldMayPointToUpToNonDomPredecessor(?hctx, ?heap, ?fld, ?ctx, ?insn, ?pred) ->
   MayHeapContext(?hctx), HeapAllocation(?heap),
   FieldSignature(?fld), MayContext(?ctx), Instruction(?insn), Instruction(?pred).

StaticFieldMayPointToUpToNonDomPredecessor(?hctx, ?heap, ?fld, ?ctx, ?insn, ?pred) <-
   MaySuccessorBBModuloThrow(?insn, ?pred),
   BasicBlockEnd(?tail),
   BasicBlockHead[?tail] = ?pred,
   StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?tail),
   !ExistsPreviousNonDomPredecessorToSameBB(?pred, ?insn).

OptStaticFieldMayPointToAtNextNonDomPredecessor(?hctx, ?heap, ?fld, ?ctx, ?insn, ?predPrev) <-
   BasicBlockEnd(?tail),
   BasicBlockHead[?tail] = ?pred,
   StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?tail),
   PreviousNonDomPredecessorToSameBB[?insn, ?pred] = ?predPrev.

StaticFieldMayPointToUpToNonDomPredecessor(?hctx1, ?heap1, ?fld, ?ctx, ?insn, ?pred),
StaticFieldMayPointToUpToNonDomPredecessor(?hctx2, ?heap2, ?fld, ?ctx, ?insn, ?pred) <-
   StaticFieldMayPointToUpToNonDomPredecessor
    (?hctx1, ?heap1, ?fld, ?ctx, ?insn, ?prevPred),
   OptStaticFieldMayPointToAtNextNonDomPredecessor
    (?hctx2, ?heap2, ?fld, ?ctx, ?insn, ?prevPred),
   NextNonDomPredecessorToSameBB[?insn, ?prevPred] = ?pred.

// For all non-dominated predecessor instructions, there is point-to information.
// We take the union.
AllNonDomPredecessors:StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn) ->
   MayHeapContext(?hctx), HeapAllocation(?heap),
   FieldSignature(?fld), MayContext(?ctx), Instruction(?insn).
   
AllNonDomPredecessors:StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn) <-
   StaticFieldMayPointToUpToNonDomPredecessor(?hctx, ?heap, ?fld, ?ctx, ?insn, ?pred),
   !(NextNonDomPredecessorToSameBB[?insn, ?pred] = _),
   !ExceptionHandlerFirstInstruction(?insn).

AllNonDomPredecessors:StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn) <-
   PrevInSameBasicBlock[?insn] = ?prev,
   StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?prev).


// Same as above, for all predecessors (not just non-dominated ones)

// Up to a certain predecessor basic block, there is
// static field point-to information. We take the union.
StaticFieldMayPointToUpToPredecessor(?hctx, ?heap, ?fld, ?ctx, ?insn, ?pred) ->
   MayHeapContext(?hctx), HeapAllocation(?heap),
   FieldSignature(?fld), MayContext(?ctx), Instruction(?insn), Instruction(?pred).

StaticFieldMayPointToUpToPredecessor(?hctx, ?heap, ?fld, ?ctx, ?insn, ?pred) <-
   MaySuccessorBBModuloThrow(?insn, ?pred),
   BasicBlockEnd(?tail),
   BasicBlockHead[?tail] = ?pred,
   StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?tail),
   !ExistsPreviousPredecessorToSameBB(?pred, ?insn).

OptStaticFieldMayPointToAtNextPredecessor
      (?hctx, ?heap, ?fld, ?ctx, ?insn, ?predPrev) <-
   BasicBlockEnd(?tail),
   BasicBlockHead[?tail] = ?pred,
   StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?tail),
   PreviousPredecessorToSameBB[?insn, ?pred] = ?predPrev.

StaticFieldMayPointToUpToPredecessor(?hctx1, ?heap1, ?fld, ?ctx, ?insn, ?pred),
StaticFieldMayPointToUpToPredecessor(?hctx2, ?heap2, ?fld, ?ctx, ?insn, ?pred) <-
   StaticFieldMayPointToUpToPredecessor
    (?hctx1, ?heap1, ?fld, ?ctx, ?insn, ?prevPred),
   OptStaticFieldMayPointToAtNextPredecessor
    (?hctx2, ?heap2, ?fld, ?ctx, ?insn, ?prevPred),
   NextPredecessorToSameBB[?insn, ?prevPred] = ?pred.

// For all predecessor instructions, there is point-to information.
// We take the union.
AllPredecessors:StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn) ->
   MayHeapContext(?hctx), HeapAllocation(?heap),
   FieldSignature(?fld), MayContext(?ctx), Instruction(?insn).
   
AllPredecessors:StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn) <-
   StaticFieldMayPointToUpToPredecessor
    (?hctx, ?heap, ?fld, ?ctx, ?insn, ?pred),
   !(NextPredecessorToSameBB[?insn, ?pred] = _),
   !ExceptionHandlerFirstInstruction(?insn).

AllPredecessors:StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?insn) <-
   PrevInSameBasicBlock[?insn] = ?prev,
   StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?prev).


/// ----------------------------------


/// CollectionMayPointTo for predecessors

// Up to a certain non-dominated predecessor basic block, there is
// collection points-to information. We take the union of all such sets.
CollectionMayPointToUpToNonDomPredecessor(?hctx, ?heap, ?hctxColl,
                                          ?collHeap, ?ctx, ?insn, ?pred) ->
   MayHeapContext(?hctx), HeapAllocation(?heap),
   MayHeapContext(?hctxColl), HeapAllocation(?collHeap),
   MayContext(?ctx), Instruction(?insn), Instruction(?pred).

CollectionMayPointToUpToNonDomPredecessor(?hctx, ?heap, ?hctxColl,
                                          ?collHeap, ?ctx, ?insn, ?pred) <-
   MaySuccessorBBModuloThrow(?insn, ?pred),
   BasicBlockEnd(?tail),
   BasicBlockHead[?tail] = ?pred,
   CollectionMayPointTo(?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?tail),
   !ExistsPreviousNonDomPredecessorToSameBB(?pred, ?insn).

OptCollectionMayPointToAtNextNonDomPredecessor
      (?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?insn, ?predPrev) <-
   BasicBlockEnd(?tail),
   BasicBlockHead[?tail] = ?pred,
   CollectionMayPointTo(?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?tail),
   PreviousNonDomPredecessorToSameBB[?insn, ?pred] = ?predPrev.

CollectionMayPointToUpToNonDomPredecessor
 (?hctx1, ?heap1, ?hctxColl, ?collHeap, ?ctx, ?insn, ?pred),
CollectionMayPointToUpToNonDomPredecessor
 (?hctx2, ?heap2, ?hctxColl, ?collHeap, ?ctx, ?insn, ?pred) <-
   CollectionMayPointToUpToNonDomPredecessor
    (?hctx1, ?heap1, ?hctxColl, ?collHeap, ?ctx, ?insn, ?prevPred),
   OptCollectionMayPointToAtNextNonDomPredecessor
    (?hctx2, ?heap2, ?hctxColl, ?collHeap, ?ctx, ?insn, ?prevPred),
   NextNonDomPredecessorToSameBB[?insn, ?prevPred] = ?pred.

// For all non-dominated predecessor instructions, there is point-to information.
// We take the union.
AllNonDomPredecessors:CollectionMayPointTo(
      ?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?insn) ->
   MayHeapContext(?hctx), HeapAllocation(?heap),
   MayHeapContext(?hctxColl), HeapAllocation(?collHeap),
   MayContext(?ctx), Instruction(?insn).
   
AllNonDomPredecessors:CollectionMayPointTo
 (?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?insn) <-
   CollectionMayPointToUpToNonDomPredecessor
    (?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?insn, ?pred),
   !(NextNonDomPredecessorToSameBB[?insn, ?pred] = _),
   !ExceptionHandlerFirstInstruction(?insn).

AllNonDomPredecessors:CollectionMayPointTo
 (?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?insn) <-
   PrevInSameBasicBlock[?insn] = ?prev,
   CollectionMayPointTo(?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?prev).


// Same as above, for all predecessors (not just non-dominated ones)

// Up to a certain predecessor basic block, there is
// collection points-to information. We take the union.
CollectionMayPointToUpToPredecessor(?hctx, ?heap, ?hctxColl, ?collHeap,
                                    ?ctx, ?insn, ?pred) ->
   MayHeapContext(?hctx), HeapAllocation(?heap),
   MayHeapContext(?hctxColl), HeapAllocation(?collHeap),
   MayContext(?ctx), Instruction(?insn), Instruction(?pred).

CollectionMayPointToUpToPredecessor(?hctx, ?heap, ?hctxColl, ?collHeap,
                                    ?ctx, ?insn, ?pred) <-
   MaySuccessorBBModuloThrow(?insn, ?pred),
   BasicBlockEnd(?tail),
   BasicBlockHead[?tail] = ?pred,
   CollectionMayPointTo(?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?tail),
   !ExistsPreviousPredecessorToSameBB(?pred, ?insn).

OptCollectionMayPointToAtNextPredecessor
 (?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?insn, ?predPrev) <-
   BasicBlockEnd(?tail),
   BasicBlockHead[?tail] = ?pred,
   CollectionMayPointTo(?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?tail),
   PreviousPredecessorToSameBB[?insn, ?pred] = ?predPrev.

CollectionMayPointToUpToPredecessor
 (?hctx1, ?heap1, ?hctxColl, ?collHeap, ?ctx, ?insn, ?pred),
CollectionMayPointToUpToPredecessor
 (?hctx2, ?heap2, ?hctxColl, ?collHeap, ?ctx, ?insn, ?pred) <-
   CollectionMayPointToUpToPredecessor
    (?hctx1, ?heap1, ?hctxColl, ?collHeap, ?ctx, ?insn, ?prevPred),
   OptCollectionMayPointToAtNextPredecessor
    (?hctx2, ?heap2, ?hctxColl, ?collHeap, ?ctx, ?insn, ?prevPred),
   NextPredecessorToSameBB[?insn, ?prevPred] = ?pred.

// For all predecessor instructions, there is point-to information.
// We take the union.
AllPredecessors:CollectionMayPointTo(?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?insn) ->
   MayHeapContext(?hctx), HeapAllocation(?heap),
   MayHeapContext(?hctxColl), HeapAllocation(?collHeap),
   MayContext(?ctx), Instruction(?insn).
   
AllPredecessors:CollectionMayPointTo(?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?insn) <-
   CollectionMayPointToUpToPredecessor
    (?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?insn, ?pred),
   !(NextPredecessorToSameBB[?insn, ?pred] = _),
   !ExceptionHandlerFirstInstruction(?insn).

AllPredecessors:CollectionMayPointTo(?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?insn) <-
   PrevInSameBasicBlock[?insn] = ?prev,
   CollectionMayPointTo(?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?prev).

/// ----------------------------------


// for all returns of a method, a certain object+field points to known sets.
// We take their union.
UpToReturnInstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?return) <-
   ReturnInstruction(?return),
   !ExistsPreviousReturn(?return),
   AllPredecessors:InstanceFieldMayPointTo
    (?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?return).

UpToReturnInstanceFieldMayPointTo(?hctx1, ?heap1, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?return),
UpToReturnInstanceFieldMayPointTo(?hctx2, ?heap2, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?return) <-
   UpToReturnInstanceFieldMayPointTo(?hctx2, ?heap2, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?prevReturn),
   NextReturn[?prevReturn] = ?return,
   AllPredecessors:InstanceFieldMayPointTo
    (?hctx1, ?heap1, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?return).

AllReturn:InstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?method) <-
   UpToReturnInstanceFieldMayPointTo(?hctx, ?heap, ?fld, ?hctxBase, ?baseHeap, ?ctx, ?return),
   !(NextReturn[?return] = _),
   Instruction:Method[?return] = ?method.


// for all returns of a method, a certain static field points to known sets.
// We take their union.
UpToReturnStaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?return) <-
   ReturnInstruction(?return),
   !ExistsPreviousReturn(?return),
   AllPredecessors:StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?return).

UpToReturnStaticFieldMayPointTo(?hctx1, ?heap1, ?fld, ?ctx, ?return),
UpToReturnStaticFieldMayPointTo(?hctx2, ?heap2, ?fld, ?ctx, ?return) <-
   UpToReturnStaticFieldMayPointTo(?hctx2, ?heap2, ?fld, ?ctx, ?prevReturn),
   NextReturn[?prevReturn] = ?return,
   AllPredecessors:StaticFieldMayPointTo(?hctx1, ?heap1, ?fld, ?ctx, ?return).

AllReturn:StaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?method) <-
   UpToReturnStaticFieldMayPointTo(?hctx, ?heap, ?fld, ?ctx, ?return),
   !(NextReturn[?return] = _),
   Instruction:Method[?return] = ?method.


// for all returns of a method, a collection points to known sets.
// We take their union.
UpToReturnCollectionMayPointTo(?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?return) <-
   ReturnInstruction(?return),
   !ExistsPreviousReturn(?return),
   AllPredecessors:CollectionMayPointTo
    (?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?return).

UpToReturnCollectionMayPointTo(?hctx1, ?heap1, ?hctxColl, ?collHeap, ?ctx, ?return),
UpToReturnCollectionMayPointTo(?hctx2, ?heap2, ?hctxColl, ?collHeap, ?ctx, ?return) <-
   UpToReturnCollectionMayPointTo(?hctx2, ?heap2, ?hctxColl, ?collHeap, ?ctx, ?prevReturn),
   NextReturn[?prevReturn] = ?return,
   AllPredecessors:CollectionMayPointTo
    (?hctx1, ?heap1, ?hctxColl, ?collHeap, ?ctx, ?return).

AllReturn:CollectionMayPointTo(?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?method) <-
   UpToReturnCollectionMayPointTo(?hctx, ?heap, ?hctxColl, ?collHeap, ?ctx, ?return),
   !(NextReturn[?return] = _),
   Instruction:Method[?return] = ?method.
